{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#geospatial-programming-course-cohort-2","title":"Geospatial Programming Course Cohort-2","text":"<p>This course is carefully designed to take you from zero coding knowledge to building professional geospatial projects\u2014step by step, in your own language, Bengali. Whether you're a student, job seeker, or researcher, each class builds on the previous one to help you understand not just how to run code, but why it works.</p> <p>We go beyond tutorials and give you the logic, tools, and portfolio to become confident in programming, Google Earth Engine (GEE), and geospatial analysis. Below is a detailed breakdown of what you'll learn in each class.</p>"},{"location":"#course-structure-class-modules","title":"\ud83d\udcda Course Structure &amp; Class Modules","text":""},{"location":"#module-1-introduction-to-programming-with-javascript","title":"\ud83d\udd30 Module 1: Introduction to Programming with JavaScript","text":"<ul> <li>Class 1: Code Begins \u2013 Variables, Data Types &amp; Comparisons</li> <li>Class 2: Making Decisions \u2013 Arithmetic &amp; Conditional Statements</li> <li>Class 3: Code That Repeats \u2013 Loops &amp; Logical Operators</li> <li>Class 4: Organize Everything \u2013 Introduction to Arrays</li> <li>Class 5: Write Once, Use Anywhere \u2013 Mastering Functions</li> <li>Class 6: Real-World Data \u2013 Understanding Objects</li> </ul>"},{"location":"#module-2-foundations-of-google-earth-engine-gee","title":"\ud83c\udf10 Module 2: Foundations of Google Earth Engine (GEE)","text":"<ul> <li>Class 7: Inside the Image \u2013 Understanding Details of Digital Image Structure</li> <li>Class 8: Beyond Pixels \u2013 GIS Data Types &amp; Vector Data in GEE</li> <li>Class 9: Power Split \u2013 GEE Client vs Server Explained</li> <li>Class 10: Dive into Data \u2013 Working with Image Collections</li> <li>Class 11: Seeing the Invisible \u2013 Calculating Indices (NDVI, NDWI, etc.)</li> <li>Class 12: From Pixels to Insights \u2013 Thresholding &amp; Area Calculations</li> <li>Class 13: Big Picture Stats \u2013 Group Reducers &amp; Zonal Statistics</li> <li>Class 14: Take it With You \u2013 Exporting Raster &amp; Vector Data</li> <li>Class 15: Map Intelligence \u2013 Supervised vs Unsupervised Machine Learning</li> </ul>"},{"location":"#module-3-real-world-applications-in-remote-sensing","title":"\ud83d\udef0\ufe0f Module 3: Real-World Applications in Remote Sensing","text":"<ul> <li>Class 16: Land from Above \u2013 Land Use &amp; Land Cover Classification</li> <li>Class 17: Spot the Change \u2013 Change Detection Techniques</li> <li>Class 18: Precision Mapping \u2013 Feature Extraction of Forest, Water &amp; Urban Areas</li> </ul>"},{"location":"#module-4-crafting-publication-ready-maps-using-qgis","title":"\ud83d\uddfa\ufe0f Module 4: Crafting Publication-Ready Maps Using QGIS","text":"<ul> <li>Class 19: Styling with Purpose \u2013 Symbology, Colors &amp; Legends in QGIS</li> <li>Class 20: Map Composition \u2013 Grids, North Arrows &amp; Scale Bars</li> <li>Class 21: Polishing Maps \u2013 Fonts, Labels &amp; Layout Design</li> <li>Class 22: Export Like a Pro \u2013 High-Resolution Map Export Techniques</li> </ul>"},{"location":"#module-5-building-your-geospatial-portfolio-with-github","title":"\ud83d\udcbc Module 5: Building Your Geospatial Portfolio with GitHub","text":"<ul> <li>Class 23: Git &amp; GitHub Basics: Creating and Hosting Projects</li> <li>Class 24: Writing a README, Documenting Your Work, Going Public</li> </ul>"},{"location":"#what-youll-learn","title":"\ud83d\udca1 What You'll Learn","text":"<ul> <li>\u2705 Programming Fundamentals \u2014 Build a solid foundation in coding concepts from scratch.</li> <li>\u2705 Google Earth Engine (GEE) \u2014 Master cloud-based geospatial analysis at scale.</li> <li>\u2705 Advanced Map Design \u2014 Unlock hidden techniques for making powerful, story-driven maps.</li> <li>\u2705 Portfolio Building \u2014 Create a complete GitHub portfolio to showcase your real-world geospatial skills.</li> <li>\u2705 Career-Ready Skills \u2014 Become confident to explore any programming language after Part 1.</li> </ul>"},{"location":"#course-structure","title":"\ud83d\udce6 Course Structure","text":"<ul> <li>\ud83c\udfa5 18 Recorded Classes \u2014  with 1-year full access to all videos.</li> <li>\ud83c\udf99\ufe0f 5 Live Interactive Sessions \u2014 Get real-time help and feedback.</li> <li>\ud83e\uddea 5 Hands-on Projects \u2014 Apply your learning to solve real problems.</li> <li>\ud83d\udcdd 20 Practical Assignments \u2014 Reinforce core concepts through practice.</li> </ul>"},{"location":"#special-benefits","title":"\ud83c\udfc6 Special Benefits","text":"<ul> <li>\ud83d\udcb5 Top 3 Performers Get Refunds!</li> <li>1st Place: 100% Course Fee Refund</li> <li>2nd Place: 70% Refund</li> <li>3rd Place: 50% Refund</li> <li>\ud83d\udcdc Certificate on Completion</li> <li>\ud83d\udd2c Chance to Work with Our Research Team</li> </ul>"},{"location":"#enrollment-payment-info","title":"\ud83d\udcb3 Enrollment &amp; Payment Info","text":"<ul> <li>\ud83c\udf93 Students: BDT 2000</li> <li>\ud83d\udcbc Professionals: BDT 3500</li> <li>Payment via bKash: 01521486364 (Send Money)</li> </ul>"},{"location":"#class-starts-25-july-2025","title":"Class starts: 25 July 2025","text":"<p>\ud83d\udcdd After payment, complete your registration through our Enrollment Form</p>"},{"location":"#watch-a-sample-class-of-the-course","title":"Watch a sample class of the Course:","text":"<p>The hidden structure of satellite imagery</p> <p></p>"},{"location":"#ready-to-start","title":"\ud83d\ude80 Ready to Start?","text":"<p>This is your chance to break into one of the most in-demand tech skills \u2014  in your own language .</p> <p>\ud83d\udce9 Seats are limited. Enroll now and start your journey into geospatial programming today!</p> <p>\u27a1\ufe0f Visit geocodinglab.com or email us (geocoder.contact@gmail.com) for more information.</p>"},{"location":"#list-of-all-video-contet-to-follow","title":"List of all video contet to follow:","text":"<p>Make sure you use the same email address that you gave during registration of the course.</p> <ul> <li>Installing vs code and node js</li> </ul> <ul> <li>Installing Npm: Requried for 2nd class </li> </ul> <ul> <li>Creating GitHub account and asking your questions</li> </ul> <ul> <li>Signup for Google Earth Engine account</li> </ul>"},{"location":"#troubleshooting-video","title":"Troubleshooting video","text":"<ol> <li>How to create JS file in VS Code-English</li> <li>Solving prompt-sync module not found-Bangla</li> </ol>"},{"location":"array-class4/","title":"Class 4 - Arrary","text":""},{"location":"array-class4/#array","title":"Array","text":"<p>Array is a powerful data structure for managing and handling data in any programming language. While the syntax and notation of arrays vary from language to language, the fundamental concepts remain similar.</p>"},{"location":"array-class4/#why-use-arrays","title":"Why Use Arrays?","text":"<p>Suppose you want to print the names of five land-use types. Without using an array, you would do it like this:</p> <pre><code>console.log(\"Waterbody\");\nconsole.log(\"Bare_land\");\nconsole.log(\"Settlement\");\nconsole.log(\"Vegetation\");\n</code></pre> <p>Instead of storing each land-use name in separate variables, using an array makes it more convenient and easier to manage. For instance:</p> <pre><code>var landUseType = [\"Waterbody\", \"Bare_land\", \"Settlement\", \"Vegetation\"];\n\nfor (var i = 0; i &lt; landUseType.length; i++) {\n  console.log(landUseType[i]);\n}\n</code></pre> <p>Arrays provide a structured way to store and access multiple values under a single variable, especially helpful when dealing with extensive lists.</p>"},{"location":"array-class4/#creating-an-array","title":"Creating an Array","text":"<p>Creating arrays in JavaScript can be done using an array literal:</p> <pre><code>var landUseType = [\"Waterbody\", \"Bare_land\", \"Settlement\", \"Vegetation\"];\n</code></pre> <p>You can also declare an empty array and assign values later:</p> <pre><code>var landUseType = [];\nlandUseType[0] = \"Waterbody\";\nlandUseType[1] = \"Bare_land\";\nlandUseType[2] = \"Settlement\";\n</code></pre>"},{"location":"array-class4/#accessing-array-elements","title":"Accessing Array Elements","text":"<p>Arrays use index numbers to access elements, starting from 0. We can access any element of an array by its relevant index. In all programming languages, indexing starts from 0.</p> <p>For example:</p> <pre><code>var ar = [\"Padma\", \"Meghna\", \"Jamuna\"];\n</code></pre> <p>In this array, the index of \"Padma\" is 0, \"Meghna\" is 1, and \"Jamuna\" is 2. The index number will increase by 1 if we add more elements. To get the first element of this array, we will use <code>ar[0]</code>.</p> <p>More examples:</p> <pre><code>var landUseType = [\"Waterbody\", \"Bare_land\", \"Settlement\", \"Vegetation\"];\n\nvar waterbody = landUseType[0]; // Accesses the first element\n</code></pre>"},{"location":"array-class4/#modifying-array-elements","title":"Modifying Array Elements","text":"<p>You can easily change the value of an array element by referencing its index:</p> <pre><code>var ar = [\"Padma\", \"Meghna\", \"Jamuna\"];\nar[0] = \"Tista\"; // Changes \"Padma\" to \"Tista\"\n</code></pre>"},{"location":"array-class4/#array-properties-and-methods","title":"Array Properties and Methods","text":"<p>JavaScript arrays come with built-in properties and methods that enhance their functionality. Some of those are:</p> <ul> <li><code>length</code>: Returns the total number of elements in an array.</li> <li><code>sort()</code>: Sorts the elements of the array.</li> </ul>"},{"location":"array-class4/#example-of-length-property","title":"Example of <code>length</code> Property:","text":"<p>The <code>length</code> property returns the number of elements in an array. Here's an example:</p> <pre><code>var fruits = [\"Apple\", \"Banana\", \"Orange\", \"Mango\"];\n\n// Get the length of the array\nvar arrayLength = fruits.length;\n\nconsole.log(\"Number of elements in the array: \" + arrayLength);\n// Output: Number of elements in the array: 4\n</code></pre>"},{"location":"array-class4/#example-of-sort-method","title":"Example of <code>sort()</code> Method:","text":"<p>The <code>sort()</code> method is used to sort the elements of an array. By default, it sorts elements as strings, so for numbers, you need to provide a comparison function:</p> <p>For sorting strings alphabetically, you don't need to provide a comparison function:</p> <p></p><pre><code>var fruits = [\"Apple\", \"Banana\", \"Orange\", \"Mango\"];\n\n// Sorting the array alphabetically\nfruits.sort();\n\nconsole.log(\"Sorted fruits: \" + fruits);\n// Output: Sorted fruits: Apple,Banana,Mango,Orange\n</code></pre> JavaScript's Map Method <p>In JavaScript, the <code>map()</code> method is a versatile tool for transforming arrays with ease and efficiency. Let's explore the <code>map()</code> method using your provided code example.</p> <p>What is <code>map()</code>?</p> <ul> <li><code>map()</code> is a built-in method in JavaScript used to transform each element of an array based on a provided function.</li> </ul> <p>Syntax</p> <pre><code>var newArray = array.map(callback(currentValue));\n</code></pre> <ul> <li><code>array</code>: The original array you want to transform.</li> <li><code>callback</code>: A function that defines the transformation for each element.</li> </ul> <p>How it Works</p> <ul> <li><code>map()</code> iterates through each element of the array.</li> <li>For each element, it applies the provided function (callback) and collects the return value into a new array.</li> <li>The resulting array contains the transformed elements, leaving the original array unchanged.</li> </ul>"},{"location":"array-class4/#example","title":"Example","text":"<pre><code>var numList = [2, 3, 4, 5]; // Original array\n\nfunction doublingNuml(num) {\n    return num * 2; // Function to double a number\n}\n\nvar doubledNum = numList.map(doublingNuml); // Using map() to double each element\n\nconsole.log(doubledNum); // Outputting the new array with doubled values\n</code></pre> <p>In your provided code example, you're using the <code>map()</code> method to double each number in the <code>numList</code> array using the <code>doublingNuml</code> function. Let's break it down:</p> <p></p><pre><code>var numList = [2, 3, 4, 5]; // Original array\n\nfunction doublingNuml(num) {\n    return num * 2; // Function to double a number\n}\n\nvar doubledNum = numList.map(doublingNuml); // Using map() to double each element\n\nconsole.log(doubledNum); // Outputting the new array with doubled values\n</code></pre> Explanation: <ol> <li>We have an array <code>numList</code> containing <code>[2, 3, 4, 5]</code>.</li> <li>We define a function <code>doublingNuml(num)</code> that takes a number <code>num</code> and returns <code>num * 2</code>, effectively doubling it.</li> <li>We use the <code>map()</code> method on the <code>numList</code> array with the <code>doublingNuml</code> function. This applies the <code>doublingNuml</code> function to each element of the array and creates a new array <code>doubledNum</code> with the doubled values.</li> <li>Finally, we log the new array <code>doubledNum</code> to the console, which contains <code>[4, 6, 8, 10]</code>, the result of applying the <code>doublingNuml</code> function to each element of the original array.</li> </ol> <p>This demonstrates how the <code>map()</code> method can be used to efficiently transform array elements based on a provided function, resulting in a new array with the transformed values.</p>"},{"location":"array-class4/#looping-through-arrays","title":"Looping Through Arrays","text":"<p>You can iterate through array elements using a <code>for</code> loop or the <code>forEach()</code> function:</p> <pre><code>// Using a for loop\nvar landUseType = [\"Waterbody\", \"Bare_land\", \"Settlement\", \"Vegetation\"];\n\nfor (var i = 0; i &lt; landUseType.length; i++) {\n  // Process each element\n}\n\n// Using forEach\nlandUseType.forEach(function (value) {\n  // Process each element\n});\n</code></pre>"},{"location":"array-class4/#adding-array-elements","title":"Adding Array Elements","text":"<p>To add new elements to an array, you can use the <code>push()</code> method or directly assign values using the length property:</p> <pre><code>var fruits = [\"Banana\", \"Orange\", \"Apple\"];\nfruits.push(\"Lemon\"); // Adds \"Lemon\" to fruits\n\n// Alternatively\nfruits[3] = \"Lemon\";\n</code></pre>"},{"location":"conditional-statements-class2/","title":"Class 2 - Arithmetic operators, conditional statements","text":""},{"location":"conditional-statements-class2/#arithmetic-operators","title":"Arithmetic operators","text":"<ul> <li> <p>Operands: These are the values or variables that operators act upon. For example, in the expression <code>5 + 3</code>, the operands are 5 and 3.. We can say 5 is the left operand, and 3 is the right operand.</p> </li> <li> <p>Operators: These are symbols or keywords that perform operations on operands. In the expression 5 + 3, the plus sign (+) is the operator that adds the operands 5 and 3. In JavaScript, arithmetic operators perform mathematical operations on numeric values. Here are the main arithmetic operators:</p> </li> </ul> <p>1.Addition (+): Adds two values together.</p> <pre><code>var sum = 5 + 3;  // sum is 8\n</code></pre> <p>2.Subtraction (-): Subtracts the right operand from the left operand.</p> <pre><code>var difference = 10 - 4;  // difference is 6\n</code></pre> <p>3.Multiplication (*): Multiplies two values.</p> <pre><code>var product = 2 * 6;  // product is 12\n</code></pre> <p>4.Division (/): Divides the left operand by the right operand.</p> <pre><code>var quotient = 8 / 2;  // quotient is 4\n</code></pre> <p>5.Remainder (%): Returns the remainder of the division of the left operand by the right operand.</p> <pre><code>var remainder = 10 % 3;  // remainder is 1\n</code></pre> <p>6.Exponentiation ( or Math.pow()):** Raises the left operand to the power of the right operand.</p> <pre><code>var power = 2 ** 3;  // power is 8\n</code></pre>"},{"location":"conditional-statements-class2/#conditional-statements","title":"Conditional statements","text":"<p>Conditional statements are essential tools in programming, allowing developers to execute different actions based on specific conditions. In JavaScript, several conditional statements facilitate this process, each serving a distinct purpose.</p>"},{"location":"conditional-statements-class2/#1-the-if-statement","title":"1. The \"if\" Statement:","text":"<p>The <code>if</code> statement is fundamental in JavaScript, enabling the execution of a block of code if a specified condition evaluates to true. For instance:</p> <pre><code>if (condition) {\n    // Code to be executed if the condition is true\n}\n</code></pre> <pre><code>var temperature = 25;\n\nif (temperature &gt; 30) {\n    console.log(\"It's a hot day!\");\n} else {\n    console.log(\"The weather is pleasant.\");\n}\n</code></pre> <p>In this example, the <code>if</code> statement checks if the <code>temperature</code> variable is greater than 30. If this condition is true, it prints \"It's a hot day!\" to the console; otherwise, it prints \"The weather is pleasant.</p> <p>Suppose the current temperature is 25. In this case, the condition <code>temperature &gt; 30</code> is false. Therefore, the code inside the <code>else</code> block is executed, and \"The weather is pleasant.\" will be logged to the console.</p>"},{"location":"conditional-statements-class2/#2-the-else-statement","title":"2. The \"else\" Statement:","text":"<p>The <code>else</code> statement complements the <code>if</code> statement, providing an alternative block of code to be executed when the initial condition is false:</p> <pre><code>if (condition) {\n    // Code to be executed if the condition is true\n} else {\n    // Code to be executed if the condition is false\n}\n</code></pre> <pre><code>var loggedIn = false;\n\nif (loggedIn) {\n    console.log(\"Welcome, user!\");\n} else {\n    console.log(\"Please log in to access the content.\");\n}\n</code></pre> <p>In this example, the <code>if</code> statement checks if the <code>loggedIn</code> variable is true. If true, it welcomes the user; otherwise, it prompts the user to log in.</p> <p>If the user is not logged in (<code>loggedIn</code> is false), the code inside the <code>else</code> block will be executed, and \"Please log in to access the content.\" will be printed in the console.</p>"},{"location":"conditional-statements-class2/#3-the-else-if-statement","title":"3. The \"else if\" Statement:","text":"<p>The <code>else if</code> statement allows for the evaluation of additional conditions after the initial <code>if</code> statement. This is useful when multiple conditions need to be considered:</p> <p></p><pre><code>if (condition1) {\n    // Code to be executed if condition1 is true\n} else if (condition2) {\n    // Code to be executed if condition2 is true\n} else {\n    // Code to be executed if neither condition1 nor condition2 is true\n}\n</code></pre> <pre><code>var hour = 15;\n\nif (hour &lt; 12) {\n    console.log(\"Good morning!\");\n} else if (hour &lt; 18) {\n    console.log(\"Good afternoon!\");\n} else {\n    console.log(\"Good evening!\");\n}\n</code></pre> <p>In this example, the <code>else if</code> statement provides an additional condition to check after the initial <code>if</code> condition. It prints a greeting based on the time of day.</p> <p>If the <code>hour</code> is 15, the first condition (<code>hour &lt; 12</code>) is false. The program then checks the next condition (<code>hour &lt; 18</code>), which is true. Therefore, \"Good afternoon!\" will be printed in the console.</p>"},{"location":"conditional-statements-class2/#exercise","title":"Exercise","text":"<ol> <li> <p>Suppose you have a login system where you can log in by using only any of three names.</p> <ul> <li>Determine three names inside your code.</li> <li>Write a code that takes the user input.</li> <li>If the user provided name doesn\u2019t match with none of your predetermined names it will display \u201cSorry! We don\u2019t find you in the system.\u201d Otherwise, it will display \u201cWelcome! \u201c.</li> </ul> </li> <li> <p>Write a code that prompts the user to enter a year. The code should display a message indicating whether the year is a leap year or not.</p> </li> <li> <p>Create a simple shopping cart program. The program should:</p> <ul> <li> <p>Prompt the user to enter the price of three items one by one.</p> </li> <li> <p>Apply a discount based on the total cost:</p> </li> <li> <p>If the total cost is greater than 50 TK, apply a 10% discount. If the total cost is greater than 100, apply a 20% discount. Use the formula: discountedCost = totalCost - (totalCost * discount)</p> </li> <li> <p>Display the final cost after applying the discount.</p> </li> </ul> </li> <li> <p>Write a code that calculates the final grade for a student based on his scores in different subjects. The program should:</p> <ul> <li> <p>Prompt the user to enter the scores for three subjects: Math, English, and Science.</p> </li> <li> <p>Calculate the average score using the formula: average = (mathScore + englishScore + scienceScore) / 3.</p> </li> <li> <p>Display the final average score.</p> </li> <li> <p>Use conditional statements to determine and display the corresponding letter grade based on the following grading scale:</p> <ul> <li> <p>A:  &gt; 60 </p> </li> <li> <p>F: &lt;60</p> </li> </ul> </li> </ul> </li> </ol>"},{"location":"exportingDataClass14/","title":"Class 14 - Exporting raster and vector data","text":""},{"location":"exportingDataClass14/#class-14","title":"Class 14","text":""},{"location":"exportingDataClass14/#working-with-feature-collections-and-exports-in-gee-js-api","title":"Working with Feature Collections and Exports in GEE JS API","text":"<p>The GEE JavaScript API offers powerful tools for manipulating and exporting geospatial data. This article explores techniques for adding properties, exporting and importing features as Shapefiles and CSVs, creating feature collections with null geometries, and exporting classified images.</p>"},{"location":"exportingDataClass14/#1-adding-properties-by-mapping-to-a-feature-collection","title":"1. Adding Properties by Mapping to a Feature Collection","text":"<p>To add properties to an existing feature collection, leverage the <code>map</code> method:</p> <pre><code>// Sample feature collection\nvar features = ee.FeatureCollection([\n  ee.Feature(ee.Geometry.Point([92, 21]), {'prop1': 10, 'prop2': 'value'}),\n  ee.Feature(ee.Geometry.Polygon([[[89, 21.6], [92.6,21.8], [91.3, 20.5]]]), {'prop1': 20})\n]);\n\n// Function to add a new property based on existing ones\nvar addAreaProperty = function(feature) {\n  return feature.set('area', feature.geometry().area());\n};\n\n// Apply the mapping function to add the 'area' property\nvar featuresWithArea = features.map(addAreaProperty);\n\nprint(featuresWithArea);\nMap.centerObject(featuresWithArea)\nMap.addLayer(featuresWithArea)\n</code></pre> <p>This code defines two features and a function <code>addAreaProperty</code> that calculates the area of each feature's geometry and adds it as a new property named 'area'. The <code>map</code> method applies this function to each feature in the collection, creating a new collection with the additional property.</p>"},{"location":"exportingDataClass14/#2-exporting-feacture-collection-as-shapefile","title":"2. Exporting feacture collection as Shapefile","text":"<p>Exporting:</p> <p>Use the <code>Export.table.toDrive</code> function to export a feature collection as a Shapefile to your Google Drive:</p> <pre><code>Export.table.toDrive({\n  collection: featuresWithArea,\n  description: 'My feature collection as Shapefile',\n  fileFormat: 'SHP', \n  folder: \"GEE_exports\"\n});\n</code></pre>"},{"location":"exportingDataClass14/#3-exporting-feature-collection-vector-data-as-csv","title":"3. Exporting feature collection/ vector Data as CSV","text":"<p>Exporting:</p> <p>Similar to Shapefiles, use the <code>Export.table.toDrive</code> function but with a different file format:</p> <pre><code>Export.table.toDrive({\n  collection: featuresWithArea,\n  description: 'My feature collection as Shapefile',\n  fileFormat: 'CSV', \n  folder: \"GEE_exports\"\n});\n</code></pre>"},{"location":"exportingDataClass14/#4-mapping-over-a-list-and-creating-feature-collection-with-null-geometry","title":"4. Mapping over a List and Creating Feature Collection with Null Geometry","text":"<ul> <li>Creating a FeatureCollection from a List of Numbers in Google Earth Engine</li> </ul> <p>We'll use the <code>ee.List</code> class to create the list and the <code>map</code> function to transform each element of the list into a feature with null geometry.</p> <ul> <li>Define the List</li> </ul> <p>First, let's define a list of numbers. We'll use the <code>ee.List</code> class to create the list.</p> <pre><code>// Create a list of numbers\nvar mylist = ee.List([2, 4, 6, 8, 10]);\n</code></pre> <ul> <li>Map over the List and Create Features</li> </ul> <p>Next, we'll use the <code>map</code> function to iterate over each element in the list. For each element, we'll create a feature with null geometry. We'll set the \"value\" property of each feature to the corresponding number from the list.</p> <pre><code>// Map over each element in the list and create a Feature with null geometry\nvar listWithFt = mylist.map(function(el) {\n  return ee.Feature(null, {\"value\": el});\n});\n</code></pre> <ul> <li>Convert Mapped List to FeatureCollection</li> </ul> <p>Now that we have a mapped list of features, we'll convert it to a <code>FeatureCollection</code> using the <code>ee.FeatureCollection</code> constructor.</p> <pre><code>// Convert the mapped list to a FeatureCollection\nvar fcWithNullGm = ee.FeatureCollection(listWithFt);\n</code></pre> <ul> <li>Visualize the FeatureCollection</li> </ul> <p>Finally, let's print the resulting <code>FeatureCollection</code> to visualize the features in the Google Earth Engine Console.</p> <pre><code>// Print the FeatureCollection\nprint(fcWithNullGm, \"FeatureCollection from list\");\n</code></pre>"},{"location":"exportingDataClass14/#exporting-a-clipped-image-from-google-earth-engine","title":"Exporting a Clipped Image from Google Earth Engine","text":"<p>We'll use the <code>ee.ImageCollection</code> class to access the dataset, apply a clipping region using a geometry, and then export the clipped image to Google Drive.</p> <ul> <li>Access the Image Collection</li> </ul> <p>First, we'll access the ESA WorldCover dataset using the <code>ee.ImageCollection</code> class. We'll chain the <code>.first()</code> method to select the first image in the collection, which represents the most recent data.</p> <pre><code>// Access the ESA WorldCover dataset and select the first image\nvar imgs = ee.ImageCollection(\"ESA/WorldCover/v200\")\n          .first();\n</code></pre> <ul> <li>Clip the Image</li> </ul> <p>Next, we'll clip the selected image using a specified region. We'll use the <code>.clip()</code> function and provide a geometry (<code>features</code>) as the clipping region.</p> <pre><code>// Clip the image to a specified region\nvar clippedImage = imgs.clip(features);\n</code></pre> <ul> <li>Export the Clipped Image</li> </ul> <p>Now that we have the clipped image, we'll export it to Google Drive using the <code>Export.image.toDrive()</code> function. We'll specify the image, scale, region, and output folder.</p> <pre><code>// Export the clipped image to Google Drive\nExport.image.toDrive({\n  image: clippedImage,\n  scale: 10,\n  region: features.geometry(),\n  folder: \"geocoder\"\n});\n</code></pre>"},{"location":"exportingDataClass14/#assignmemnt-14","title":"Assignmemnt 14","text":"<ol> <li> <p>Select a feature collection of 5 waterbodies and add a property by using    map() method -4</p> </li> <li> <p>Map over a list and create a feature collection by passing null geometry to each element of that list -4</p> </li> <li> <p>Export the feature collection as CSV -2</p> </li> </ol> <p>Submision link: Check your email</p> <p>Dead line:  31 May, 2024 </p>"},{"location":"function-class5/","title":"class 5 - Function","text":""},{"location":"function-class5/#a-beginners-guide-to-functions","title":"A Beginner's Guide to Functions","text":"<p>Functions in programming act like organized sets of instructions to perform specific tasks, and they are crucial concepts that are common in all programming languages. In this article, we'll simplify the basics of functions, focusing on their structure, usage, and significance. JavaScript will serve as our example, and we'll touch on passing parameters into functions and handling them within the function.</p>"},{"location":"function-class5/#anatomy-of-a-function","title":"Anatomy of a Function","text":"<p>In JavaScript, creating a function involves using the <code>function</code> keyword, followed by a name and parentheses. Parameters, if needed, are placed inside these parentheses. The actual code of the function is enclosed in curly brackets.</p> <pre><code>function greet(name) {\n  // code to be executed\n}\n</code></pre> <p>Here, <code>name</code> is a parameter, acting as a placeholder for a value that you'll provide when using the function.</p>"},{"location":"function-class5/#using-a-function","title":"Using a Function","text":"<p>Functions are like tools; they get things done when used. This can happen when an event occurs or when you manually call the function.</p> <pre><code>// Example of manual use with a parameter\ngreet(\"Alice\");\n</code></pre>"},{"location":"function-class5/#passing-parameters","title":"Passing Parameters","text":"<p>When calling a function, you can pass values into it as arguments. These values are assigned to the parameters declared in the function.</p> <pre><code>function multiply(a, b) {\n  return a * b;\n}\n\nvar result = multiply(4, 3); // result will be 12\n</code></pre> <p>Here, <code>4</code> and <code>3</code> are passed as arguments to the <code>multiply</code> function, and they are caught by the parameters <code>a</code> and <code>b</code> inside the function.</p>"},{"location":"function-class5/#optional-parameters","title":"Optional Parameters","text":"<p>Not all functions require parameters. You can define a function without any, or you can have some parameters that are optional.</p> <pre><code>function sayHello() {\n  return \"Hello!\";\n}\n\nvar greeting = sayHello(); // greeting will be \"Hello!\"\n</code></pre>"},{"location":"function-class5/#why-use-functions","title":"Why Use Functions?","text":"<p>Functions bring several advantages to your code:</p> <ol> <li> <p>Reuse Code: Write a piece of code once and use it as many times as needed.</p> </li> <li> <p>Adaptability: Use the same code with different inputs to get different results.</p> </li> <li> <p>Readability: Functions make your code more organized and easier to understand.</p> </li> </ol>"},{"location":"function-class5/#the-brackets-operator","title":"The Brackets () Operator","text":"<p>To invoke a function and make it run, you use the parentheses <code>()</code>. Inside these parentheses, you put the values needed by the function, if any.</p> <pre><code>function square(number) {\n  return number * number;\n}\n\nvar squaredValue = square(5); // squaredValue will be 25\n</code></pre>"},{"location":"function-class5/#functions-as-variables","title":"Functions as Variables","text":"<p>In JavaScript, functions can be treated like variables. You can use them directly in assignments and calculations.</p> <pre><code>var greetingText = \"Welcome, \" + greet(\"Bob\") + \"!\";\n</code></pre>"},{"location":"function-class5/#local-variables","title":"Local Variables","text":"<p>Variables created inside a function are local; they exist only within that function. This allows you to use the same variable name in different functions without conflicts.</p> <p></p><pre><code>function countItems(items) {\n  var itemCount = items.length;\n  return \"There are \" + itemCount + \" items.\";\n}\n</code></pre> In this function, <code>itemCount</code> is declared inside the <code>countItems</code> function, making it local to that function. The value of <code>itemCount</code> is determined based on the length of the <code>items</code> array passed as an argument, and the function returns a string that includes the calculated <code>itemCount</code>."},{"location":"gee-client-server-side-class9/","title":"Class 9 - GEE client VS Server","text":""},{"location":"gee-client-server-side-class9/#class-9","title":"Class 9","text":"<p>Understanding Client vs. Server in Google Earth Engine (GEE)</p> <p>GEE employs a client-server architecture, where your local machine (client) interacts with Google's powerful servers for geospatial analysis. This distinction is essential for crafting efficient and effective GEE scripts.</p> <p>Client-Side (Local) Functions</p> <ul> <li>Reside in your web browser or development environment.</li> <li>Focus on tasks that don't require heavy processing or access to Earth Engine's geospatial capabilities.</li> <li>Common examples:<ul> <li>Debugging: Use <code>print()</code> to inspect variable values during script development:     <pre><code>var myValue = 10;\nprint(myValue); // Outputs: 10 (seen in the console)\n</code></pre></li> <li>Visualization: Employ <code>Map()</code> to display results on the Earth Engine map interface for visual exploration:     <pre><code>var myImage = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140408');\nMap.setCenter(-122.33, 37.86, 10); // Set map center\nMap.addLayer(myImage); // Add image to map for viewing\n</code></pre></li> <li>User Interaction: Create client-side functions to accept user input for filtering, calculations, or modifying map displays:     <pre><code>var myCollection = ee.ImageCollection(\"COPERNICUS/S2_SR_HARMONIZED\");\nvar userSelectedYear = parseInt(prompt(\"Enter a year (e.g., 2020):\"));\nvar filteredCollection = myCollection.filter(ee.Filter.eq('year', userSelectedYear));\n// ... use filteredCollection further in your script\n</code></pre></li> </ul> </li> </ul> <p>Server-Side (Remote) Functions</p> <ul> <li>Execute on Google's high-performance servers specifically designed for geospatial processing of large datasets.</li> <li>Examples encompassing essential GEE operations:<ul> <li>Data Loading: Use <code>ee.Image()</code> and <code>ee.FeatureCollection()</code> to access and manipulate imagery and feature datasets:     <pre><code>var landsatImage = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140408');\nvar forestFeatures = ee.FeatureCollection('FAO/FRA/2015/global_forest_extent');\n</code></pre></li> <li>Image Processing: Utilize methods like <code>select()</code>, <code>normalizedDifference()</code>, <code>clip()</code>, <code>mask()</code>, and various mathematical operators for image analysis:     <pre><code>var ndvi = landsatImage.normalizedDifference(['nir', 'red']);\nvar clippedNDVI = ndvi.clip(forestFeatures); // Clip NDVI to forest area\n</code></pre></li> <li>Feature Analysis: Leverage methods like <code>filter()</code>, <code>map()</code>, and reduction operations (<code>sum()</code>, <code>mean()</code>) to analyze feature collections:     <pre><code>var filteredForests = forestFeatures.filter(ee.Filter.gte('tree_cover', 30)); // Filter for high tree cover\nvar forestArea = filteredForests.reduceAreas().get('areas'); // Calculate total forest area\n</code></pre></li> </ul> </li> </ul>"},{"location":"gee-client-server-side-class9/#earth-engine-proxy-objects-and-data-locality","title":"Earth Engine Proxy Objects and Data Locality","text":"<p>It's crucial to distinguish Earth Engine objects from other JavaScript objects or primitives in your code. You can't directly manipulate data on the server. Instead, you interact with server-side objects through client-side \"proxy\" objects in your script. These proxy objects, recognizable by anything starting with <code>ee.</code> , act as handles for the actual data residing on Google's servers. They don't contain the data themselves but facilitate communication between your local environment and the server.</p> <p>Key Considerations and Best Practices</p> <ul> <li>Prioritize Server-Side: Focus on using server-side functions (starting with <code>ee.</code>) for the core of your geospatial analysis tasks, leveraging Google's computational power.</li> <li>Client-Side for Presentation and Interaction: Keep client-side functions for visualizing results, debugging, handling user input, and refining map displays.</li> <li>Clear Separation: Structure your code with a clear distinction between client-side and server-side operations to enhance readability and maintainability. Use comments to explain specific sections of your code.</li> <li>Efficiency: When possible, minimize client-side processing by pre-computing results server-side and transmitting only necessary data to the client for visualization.</li> <li>Avoid Mixing: Keep client-side and server-side logic separate whenever feasible to prevent unintended consequences or performance issues.</li> </ul>"},{"location":"gee-client-server-side-class9/#working-with-server-side-objects-in-google-earth-engine-gee","title":"Working with Server-Side Objects in Google Earth Engine (GEE)","text":"<p>Google Earth Engine (GEE) utilizes a functional programming approach where operations are performed using methods associated with each server-side object. This structure promotes clear and efficient manipulation of geospatial data. Here's a breakdown of essential server-side objects and their operations:</p> <p>1. ee.Number(): Performing Arithmetic and Logical Operations</p> <p>The <code>ee.Number()</code> object represents numerical values in GEE. It offers methods for performing arithmetic and logical operations on these values.</p> <ul> <li> <p>Arithmetic Operations:</p> <ul> <li><code>add()</code>: Addition (e.g., <code>num1.add(num2)</code>)</li> <li><code>subtract()</code>: Subtraction (e.g., <code>num1.subtract(num2)</code>)</li> <li><code>multiply()</code>: Multiplication (e.g., <code>num1.multiply(num2)</code>)</li> <li><code>divide()</code>: Division (e.g., <code>num1.divide(num2)</code>)</li> </ul> </li> <li> <p>Logical Operations (Comparisons):</p> <ul> <li>Logical comparisons are performed using methods like <code>gt()</code>, <code>lt()</code>, <code>eq()</code>, etc., within <code>ee.Comparison</code>. These methods evaluate to true or false and are crucial for conditional statements and filtering operations.<ul> <li><code>gt()</code>: Greater than (e.g., <code>num1.gt(num2)</code>)</li> <li><code>lt()</code>: Less than (e.g., <code>num1.lt(num2)</code>)</li> <li><code>eq()</code>: Equal to (e.g., <code>num1.eq(num2)</code>)</li> </ul> </li> </ul> </li> </ul> <p>Example:</p> <pre><code>// Define ee.Number objects\nvar num1 = ee.Number(5);\nvar num2 = ee.Number(3);\n\n// Arithmetic operations\nvar sum = num1.add(num2);\nvar difference = num1.subtract(num2);\n\n// Logical operations\nvar isGreaterThan = num1.gt(num2); // True\nvar isEqual = num1.eq(num2); // False\n\nprint(\"Arithmetic Operations:\");\nprint(\"Sum:\", sum);\nprint(\"Difference:\", difference);\n\nprint(\"\\nLogical Operations:\");\nprint(\"Is num1 greater than num2?\", isGreaterThan);\nprint(\"Are num1 and num2 equal?\", isEqual);\n</code></pre> <p>2. ee.List(): Managing Ordered Collections</p> <p>An <code>ee.List</code> object represents an ordered collection of elements of any data type in GEE. It's a versatile structure for storing and manipulating various kinds of information within your scripts.</p> <ul> <li>Common Operations:<ul> <li><code>ee.List([element1, element2, ...])</code>: Create a list.</li> <li><code>get(index)</code>: Access elements by their position (0-based indexing).</li> <li><code>size()</code>: Get the number of elements in the list.</li> <li><code>add(element)</code>: Add an element to the end of the list.</li> <li>Additional methods: Explore methods for filtering, mapping, and iterating over lists.</li> </ul> </li> </ul> <p>Example:</p> <pre><code>// Define an ee.List\nvar myList = ee.List([10, \"apple\", ee.Number(3.14)]);\n\n// Accessing elements\nvar firstElement = myList.get(0); // 10\nvar secondElement = myList.get(1); // \"apple\"\n\n// Length of the list\nvar listLength = myList.size(); // 3\n\nprint(\"List Operations:\");\nprint(\"First element:\", firstElement);\nprint(\"List length:\", listLength);\n</code></pre> <p>3. ee.Dictionary(): Storing Key-Value Pairs</p> <p>An <code>ee.Dictionary</code> object represents a collection of key-value pairs in GEE. Keys must be strings, while values can be any data type. It's useful for storing configuration options or associating metadata with features.</p> <ul> <li>Common Operations:<ul> <li><code>ee.Dictionary({key1: value1, key2: value2, ...})</code>: Create a dictionary.</li> <li><code>get(key)</code>: Access a value by its key.</li> <li><code>contains(key)</code>: Check if a key exists in the dictionary.</li> <li><code>set(key, value)</code>: Add or update a key-value pair.</li> <li><code>remove(key)</code>: Remove a key-value pair.</li> </ul> </li> </ul> <p>Example:</p> <pre><code>// Define an ee.Dictionary\nvar myDict = ee.Dictionary({\n  \"name\": \"My Image\",\n  \"resolution\": 30,\n  \"bands\": ee.List([\"red\", \"green\", \"blue\"])\n});\n\n// Accessing values\nvar imageName = myDict.get(\"name\"); // Access value by key: \"My Image\"\n\n// Checking if a key exists\nvar containsResolution = myDict.contains(\"resolution\"); // true\n\n// Adding a new key-value pair\nmyDict = myDict.set(\"year\", 2022);\n\n// Removing a key-value pair\nmyDict = myDict.remove([\"bands\"]);\n\n// Display the dictionary\nprint(\"Dictionary:\", myDict);\n</code></pre>"},{"location":"gee-client-server-side-class9/#assignment-on-class-9","title":"Assignment on Class 9","text":"<ul> <li> <pre><code>{\n  \"name\":\"Your_name\",\n  \"hobby\":\"reading\",\n  \"numList\":[2,3,4,5,6,7,9]\n}\n</code></pre> Convert above key-value pair into a Dictionary object. Get the numList from the dictionary. Apply reducer to the list and print the sum of the numList. Upload the GEE code link in your github repo. Submit your repo link.  -3 <ul> <li> <p><code>[4,5,7,8,,9]</code> Convert the list into a GEE List object. Apply the map method and multiply the value of each element of the list by 4. Finally print the multiplied list. Upload the GEE code link in your github repo. Submit your repo link. -2 </p> <ul> <li> <p>Upload upazila boundary shape file of Bangladesh to GEE asset tab. Filter out your desired upazila, and print the area, and perimeter of your upazila. Finally, show your upazila in the map. Take a screenshot of the map. Upload the screenshot, GEE code link in your github repo. Submit your repo link. -5 </p> <p>Submision link: Check your email</p> <p>Dead line: 17 March, 2024</p>"},{"location":"groupReducerClass13/","title":"Class 13 - Group Reducer and Zonal statistics","text":""},{"location":"groupReducerClass13/#class-13","title":"Class 13","text":""},{"location":"groupReducerClass13/#introduction-to-group-reducer-in-google-earth-engine","title":"Introduction to Group Reducer in Google Earth Engine","text":"<p>In Google Earth Engine (GEE), the Group Reducer is a powerful tool used to perform statistical computations on grouped data within feature collections or tables. This functionality allows users to aggregate data based on specific groupings, such as administrative boundaries, land cover types, or any other categorical variable present in the dataset. By applying reducers to grouped data, analysts can derive valuable insights and summaries for further analysis and visualization.</p>"},{"location":"groupReducerClass13/#understanding-group-reducer","title":"Understanding Group Reducer","text":""},{"location":"groupReducerClass13/#what-is-grouping","title":"What is Grouping?","text":"<p>Grouping refers to the process of categorizing data based on common attributes or values within a specified field. For instance, if we have a feature collection representing administrative districts, grouping the data by district name would create distinct groups, with each group containing features associated with a particular district.</p>"},{"location":"groupReducerClass13/#what-is-a-reducer","title":"What is a Reducer?","text":"<p>A reducer is a function used to aggregate data within a feature collection or table. Common reducers include calculating statistics such as mean, median, sum, standard deviation, etc. Reducers can operate on individual values or groups of values within the dataset.</p>"},{"location":"groupReducerClass13/#group-reducer-in-gee","title":"Group Reducer in GEE:","text":"<p>The Group Reducer in GEE combines the concepts of grouping and reducing, allowing users to calculate aggregate statistics for each group within a feature collection. It enables users to specify the field for grouping and apply a reducer function to compute statistics for each group.</p>"},{"location":"groupReducerClass13/#how-reducecolumns-works-on-feature-collections","title":"How <code>reduceColumns</code> Works on Feature Collections","text":"<p>The <code>reduceColumns</code> function in GEE is used to aggregate data across the columns of a feature collection or table. It allows users to specify selectors (columns) on which to perform the reduction operation and applies a reducer function to compute the result.</p>"},{"location":"groupReducerClass13/#syntax","title":"Syntax:","text":"<pre><code>featureCollection.reduceColumns({\n  selectors: [\"selector1\", \"selector2\", ...],\n  reducer: ee.Reducer.function()\n});\n</code></pre>"},{"location":"groupReducerClass13/#working-principle","title":"Working Principle:","text":"<ol> <li>Selectors:</li> <li> <p>Selectors are the columns or properties within the feature collection on which the reduction operation will be performed. Users specify the selectors as an array of strings.</p> </li> <li> <p>Reducer:</p> </li> <li> <p>The reducer defines the operation to be applied to the selected columns. It could be a basic statistical function like mean, sum, median, or a custom reducer function.</p> </li> <li> <p>Reduction Operation:</p> </li> <li> <p>The <code>reduceColumns</code> function aggregates the data across the specified selectors using the provided reducer. It computes the result for each selector, producing a single value for each.</p> </li> <li> <p>Output:</p> </li> <li>The output of <code>reduceColumns</code> is a dictionary-like object containing the computed result for each selector.</li> </ol>"},{"location":"groupReducerClass13/#example","title":"Example","text":"<p>Suppose we have a <code>featureCollection</code> or shapefile named <code>table</code>, containing numerical values in the columns \"F_TL\" and \"M_TL\", and text values in the column \"ADM2_NAME\". Now, let's see how we can apply group reducers for the columns holding numerical values.</p> <p>Download the dummy data set from here </p><pre><code>// Define the featureCollection or shapefile named table\n// var table = ...\n\n// Perform the reduction operation\nvar reducedVal = table.reduceColumns({\n  selectors: [\"F_TL\",\"M_TL\",\"ADM2_NAME\"],\n  reducer: ee.Reducer.mean().repeat(2).group({\n    groupField: 2,\n    groupName: \"District\"\n  })\n});\n</code></pre> <ol> <li>Selectors:</li> <li> <p>The <code>selectors</code> parameter specifies which columns of the feature collection (<code>table</code> in this case) to include in the reduction operation. In this code, the columns \"F_TL\" and \"M_TL\" will be reduced.</p> </li> <li> <p>Reducer:</p> </li> <li> <p>The <code>reducer</code> parameter defines the operation to be applied to the selected columns. In this code:</p> <ul> <li><code>ee.Reducer.mean()</code> specifies that the mean (average) of the values should be calculated.</li> <li><code>.repeat(2)</code> indicates that the mean operation should be repeated twice. This means that for each selected column, the mean will be calculated twice.</li> <li><code>.group({ groupField: 2, groupName: \"District\" })</code> specifies that the results should be grouped by the values in the \"ADM2_NAME\" column, which contains the names of districts. Each group will be assigned the name \"District\".</li> </ul> </li> <li> <p>Output:</p> </li> <li>The result of the reduction operation is stored in the variable <code>reducedVal</code>. It contains the aggregated statistics for each district (group) within the feature collection. The statistics include the mean values of \"F_TL\" and \"M_TL\" for each district.</li> </ol>"},{"location":"groupReducerClass13/#introduction-to-group-reducer-for-raster-images","title":"Introduction to Group Reducer for Raster Images:","text":"<p>In Google Earth Engine (GEE), the group reducer is a powerful tool used to aggregate and summarize data within raster images based on specific criteria, such as land cover classes or other categorical variables. It allows users to efficiently group and analyze pixel values within an image, providing valuable insights into the spatial distribution of features. Let's see an example: </p> <pre><code>// Define the region of interest (ROI)\n// var roi =..........;\n\n// Import the \"ESA/WorldCover/v200\" image collection and clip to ROI\nvar img = ee.ImageCollection(\"ESA/WorldCover/v200\")\n            .first().clip(roi);\n\n// Calculate pixel area and add bands\nvar areaImage = ee.Image.pixelArea().addBands(img);\n\n// Reduce regions to aggregate pixel area by land cover class within ROI\nvar lcArea = areaImage.reduceRegions({\n                collection: roi,\n                reducer: ee.Reducer.sum().group({\n                  groupField: 1, \n                  groupName: \"Class\"\n                }),\n                scale: 10\n              });\n\n// Print the results of land cover area calculation\nprint(lcArea);\n\n// Visualize the original satellite imagery clipped to the ROI\nMap.addLayer(img);\n</code></pre>"},{"location":"groupReducerClass13/#steps","title":"Steps:","text":"<ol> <li>Importing and Clipping Satellite Imagery:</li> <li>Import the \"ESA/WorldCover/v200\" image collection using <code>ee.ImageCollection(\"ESA/WorldCover/v200\")</code>.</li> <li>Select the first image from the collection using <code>.first()</code>.</li> <li> <p>Clip the selected image to a specified region of interest (ROI) using <code>.clip(roi)</code>.</p> </li> <li> <p>Calculating Pixel Area and Adding Bands:</p> </li> <li>Calculate the pixel area using <code>ee.Image.pixelArea()</code>.</li> <li> <p>Add bands from the original image to the pixel area image using <code>.addBands(img)</code>.</p> </li> <li> <p>Reducing Regions with Group Reducer:</p> </li> <li>Use the <code>reduceRegions</code> function to aggregate pixel area by land cover class within the ROI.</li> <li>Specify the ROI using the <code>collection</code> parameter.</li> <li>Apply the <code>ee.Reducer.sum()</code> to calculate the sum of pixel area.</li> <li>Group the results by the land cover class using <code>.group({ groupField: 1, groupName: \"Class\" })</code>. Here, <code>groupField: 1</code> indicates the band index of the land cover class.</li> <li> <p>Set the scale to 10 meters.</p> </li> <li> <p>Printing and Visualizing Results:</p> </li> <li>Print the results of land cover area calculation using <code>print(lcArea)</code>.</li> <li>Visualize the original satellite imagery clipped to the ROI using <code>Map.addLayer(img)</code>.</li> </ol>"},{"location":"groupReducerClass13/#understanding-the-group-reducer","title":"Understanding the Group Reducer:","text":"<p>In this code, we utilize the <code>ee.Reducer.sum().group()</code> function to calculate the sum of pixel area for each land cover class within the ROI. Here's how the group reducer works:</p> <ul> <li>Grouping by Land Cover Class:</li> <li>We specify <code>groupField: 1</code> to indicate that we want to group the results by the second band of the image, which represents the land cover class.</li> <li> <p>The <code>groupName: \"Class\"</code> parameter assigns the name \"Class\" to the grouped field in the output.</p> </li> <li> <p>Applying Reducer to Grouped Data:</p> </li> <li>After grouping by land cover class, we apply the <code>ee.Reducer.sum()</code> to calculate the sum of pixel area within each land cover class.</li> </ul> <p>### Assignmemnt 13</p> <ul> <li> <p>Download this dummy data set from here. Reduce any three column, and group division. Upload the code, code link, and screenshot in your github repo. Submit the repo link.- 3</p> </li> <li> <p>Use this landcover data set and calculate the sum of each class of the band <code>LC_Type1</code> for your upazila for the year 2021. Upload the code, code link, and screenshot in your github repo. Submit the repo link. -3</p> </li> <li> <p>Watch this tutorial, and make a map of your district by using QGIS. Upload the map in your github repo, share your map in  our facebook group. Give hashtags: #assignment13, #QGISMapping, #geospatialProgramming in your post. Submit the link of your facebook post. -4</p> </li> </ul> <p>Submision link: Check your email</p> <p>Dead line:  15 May, 2024 </p>"},{"location":"image-formation-class7/","title":"Class 7 - Basic structure of an image","text":""},{"location":"image-formation-class7/#how-we-see-any-object","title":"How we see any object?","text":"<p>To see an object, three things are required: </p> <p>There should be some light source.</p> <ol> <li> <p>Light from a light source should fall on an object and  the object should reflect light that falls on its surface.</p> </li> <li> <p>Light reflected from the object should reach our eye.</p> </li> </ol> <p></p> <p></p>"},{"location":"image-formation-class7/#light-absorption-and-reflection","title":"Light absorption and reflection","text":"<ul> <li> <p>Absorption: Trees absorb more red light and reflect more near-infrared light. </p> </li> <li> <p>Reflection: Healthy vegetation, including trees, tends to reflect more near-infrared light and less red light. This results in a higher NDVI value. Unhealthy or sparse vegetation may have a lower NDVI value due to reduced reflectance in the near-infrared spectrum.</p> </li> </ul>"},{"location":"image-formation-class7/#light-absorption-and-reflection-by-plant","title":"Light absorption and reflection by plant","text":""},{"location":"image-formation-class7/#remote-sensing","title":"Remote sensing","text":"<p>Remote sensing is the process of collecting information about an object or area without making physical contact with it.  There are two main types of remote sensing, based on how they collect data: active and passive.</p> <p></p>"},{"location":"image-formation-class7/#passive-remote-sensing","title":"**Passive remote sensing","text":"<p>Passive remote sensing is a\u00a0type of remote sensing that detects natural energy that is reflected or emitted by an object.  </p> <p></p>"},{"location":"image-formation-class7/#how-computer-see-an-image","title":"How computer see an image?","text":"<p>When a computer \"sees\" an image, it doesn't perceive it like humans do. Instead, it breaks it down into tiny dots called pixels. Each pixel has a color value represented by numbers. These numbers tell the computer how much red, green, and blue are present in that pixel, forming different colors.</p>"},{"location":"image-formation-class7/#formation-of-a-black-and-white-image","title":"Formation of a black and white image","text":"<p>For a black and white image, each pixel is either black or white, represented by numbers where 0 might indicate black and 1 might indicate white. The computer reads these values to create the image.</p> <p></p>"},{"location":"image-formation-class7/#formation-of-a-rgb-image","title":"Formation of a RGB image","text":"<ul> <li> <p>An RGB (Red, Green, Blue) image is formed by combining three different color channels: red, green, and blue. Each pixel in the image is represented by a combination of intensity values for these three colors.</p> </li> <li> <p>For example, a pixel might have a certain intensity of red, green, and blue, which together create a specific color. The intensity values for each color channel typically range from 0 to 255, where 0 represents no intensity (no color) and 255 represents maximum intensity (full color).</p> </li> </ul> <p></p> <p></p>"},{"location":"image-formation-class7/#rgb-channel-separation","title":"RGB channel separation","text":""},{"location":"image-formation-class7/#multispectral-imagery","title":"Multispectral Imagery","text":"<p>-Multispectral imagery captures data in a few discrete bands within the electromagnetic spectrum, typically ranging from three to ten bands.</p> <p>-These bands are usually selected to correspond to specific wavelengths where particular features or materials of interest exhibit unique spectral signatures.</p> <p>-Multispectral imagery is commonly used in applications such as land cover classification, agriculture monitoring, and environmental assessment.</p>"},{"location":"image-formation-class7/#multispectral-bands","title":"Multispectral Bands","text":"<ul> <li>Blue (B): Wavelength Range: 450 - 520 nanometers (nm)</li> <li>Green (G): Wavelength Range: 520 - 600 nm</li> <li>Red (R): Wavelength Range: 630 - 690 nm</li> <li>Near Infrared (NIR): Wavelength Range: 750 - 950 nm</li> <li>Shortwave Infrared (SWIR):</li> <li>SWIR-1: Wavelength Range: 1,350 - 1,750 nm</li> <li>SWIR-2: Wavelength Range: 1,750 - 2,500 nm</li> </ul>"},{"location":"image-formation-class7/#multispectral-bands-of-satellite","title":"Multispectral Bands of Satellite","text":"<p>Few satellites commonly used for multispectral remote sensing along with their spectral bands:</p> <ol> <li>Landsat Program:</li> <li>Landsat 8:<ul> <li>Band 1 (Coastal/Aerosol): 0.433 - 0.453 \u00b5m</li> <li>Band 2 (Blue): 0.450 - 0.515 \u00b5m</li> <li>Band 3 (Green): 0.525 - 0.600 \u00b5m</li> <li>Band 4 (Red): 0.630 - 0.680 \u00b5m</li> <li>Band 5 (Near Infrared): 0.845 - 0.885 \u00b5m</li> <li>Band 6 (Shortwave Infrared 1): 1.560 - 1.660 \u00b5m</li> <li>Band 7 (Shortwave Infrared 2): 2.100 - 2.300 \u00b5m</li> </ul> </li> <li> <p>Landsat 7 (ETM+):</p> <ul> <li>Similar to Landsat 8 with slight differences.</li> </ul> </li> <li> <p>Sentinel-2:</p> </li> <li> <p>Sentinel-2A and Sentinel-2B:</p> <ul> <li>Band 1 (Coastal/Aerosol): 0.443 - 0.453 \u00b5m</li> <li>Band 2 (Blue): 0.490 - 0.510 \u00b5m</li> <li>Band 3 (Green): 0.559 - 0.570 \u00b5m</li> <li>Band 4 (Red): 0.650 - 0.680 \u00b5m</li> <li>Band 5 (Vegetation Red Edge): 0.697 - 0.713 \u00b5m</li> <li>Band 6 (Vegetation Red Edge): 0.732 - 0.748 \u00b5m</li> <li>Band 7 (Vegetation Red Edge): 0.773 - 0.793 \u00b5m</li> <li>Band 8 (Near Infrared): 0.783 - 0.899 \u00b5m</li> <li>Band 8A (Narrow Near Infrared): 0.855 - 0.875 \u00b5m</li> <li>Band 9 (Water Vapor): 0.940 - 0.960 \u00b5m</li> <li>Band 10 (Cirrus): 1.360 - 1.390 \u00b5m</li> <li>Band 11 (Shortwave Infrared 1): 1.560 - 1.660 \u00b5m</li> <li>Band 12 (Shortwave Infrared 2): 2.100 - 2.300 \u00b5m</li> </ul> </li> <li> <p>MODIS (Moderate Resolution Imaging Spectroradiometer):</p> </li> <li>MODIS on Terra and Aqua:<ul> <li>36 spectral bands in total covering visible, near-infrared, and thermal wavelengths.</li> </ul> </li> </ol>"},{"location":"imgcollection-class10/","title":"Class 10 - GEE image collection","text":""},{"location":"imgcollection-class10/#class-10","title":"Class 10","text":""},{"location":"imgcollection-class10/#understanding-google-earth-engine-gee-image-collection","title":"Understanding Google Earth Engine (GEE) Image Collection","text":"<p>Google Earth Engine (GEE) offers a powerful platform for analyzing and processing geospatial data at scale. Central to its functionality is the concept of image collections, which comprise a vast array of satellite imagery, each with its unique characteristics and applications. In this article, we will delve into the intricacies of GEE image collections, covering various satellite sources, resolutions, filtering, reduction techniques, and metadata. Additionally, we'll explore the creation of simple RGB and false-color composites using GEE.</p>"},{"location":"imgcollection-class10/#1-different-types-of-satellite-collections","title":"1. Different Types of Satellite Collections","text":"<p>GEE hosts an extensive collection of satellite imagery from various sources, each serving distinct purposes and possessing specific characteristics. Some prominent satellite collections include Landsat, Sentinel, MODIS, and more. See GEE data catalog for more details</p>"},{"location":"imgcollection-class10/#example-accessing-landsat-image-collection","title":"Example: Accessing Landsat Image Collection","text":"<pre><code>//Landsat 8, collection 2 tierl 1, TOA data set \nvar l8 = ee.ImageCollection(\"LANDSAT/LC08/C02/T1_TOA\")\n\n//now let's take the first image from the collection and print it            \nprint(l8.first())\n</code></pre>"},{"location":"imgcollection-class10/#2-different-resolutions-spectral-spatial-temporal","title":"2. Different Resolutions: Spectral, Spatial, Temporal","text":"<p>Satellite imagery varies in resolution across different dimensions: spectral bands, spatial resolution, and temporal frequency.</p> <ul> <li>Spectral Resolution: This refers to the number of wavelengths (bands) captured by the satellite sensor.  Landsat, for example, provides data in several bands, allowing analysis of vegetation health or differentiating between different types of rock. </li> <li>Spatial Resolution: This defines the level of detail captured in an image. High-resolution satellites like WorldView provide pixel sizes of less than a meter, enabling visualization of individual objects. </li> <li>Temporal Resolution:  This indicates the frequency with which a satellite revisits the same location. Landsat revisits every 16 days, while Sentinel-2 offers 5-day revisits, allowing for more frequent monitoring of dynamic phenomena.</li> </ul>"},{"location":"imgcollection-class10/#3-filtering-image-collection","title":"3. Filtering Image Collection","text":"<p>Filtering an image collection is crucial to narrow down to specific imagery relevant to the analysis. Filters can be applied based on criteria like date, location, cloud cover, and metadata properties.</p>"},{"location":"imgcollection-class10/#example-filtering-landsat-by-cloud-cover","title":"Example: Filtering Landsat by Cloud Cover","text":"<pre><code>var maxCloudCover = 20; // Maximum allowable cloud cover percentage\nvar filteredLandsat = landsatCollection\n  .filterDate(startDate, endDate)\n  .filterBounds(regionOfInterest)\n  .filterMetadata('CLOUD_COVER', 'less_than', maxCloudCover);\nprint(filteredLandsat);\n</code></pre>"},{"location":"imgcollection-class10/#example-filtering-landsat-by-date-and-region","title":"Example: Filtering Landsat by Date and Region","text":"<pre><code>var startDate = '2020-01-01';\nvar endDate = '2020-12-31';\nvar regionOfInterest = ee.Geometry.Point(91.79, 22.34);\nMap.centerObject(regionOfInterest)\nvar filteredLandsat = l8\n  .filterDate(startDate, endDate)\n  .filterBounds(regionOfInterest);\nprint(filteredLandsat);\n</code></pre>"},{"location":"imgcollection-class10/#4-reducing-image-collection","title":"4. Reducing Image Collection","text":"<p>Reducing an image collection involves aggregating multiple images into a single composite image, often through operations like median or mean, to obtain a clearer representation of the data.</p>"},{"location":"imgcollection-class10/#example-reducing-landsat-collection-to-median-composite","title":"Example: Reducing Landsat Collection to Median Composite","text":"<pre><code>var medianComposite = filteredLandsat.median();\nprint('Median Composite:', medianComposite);\nMap.addLayer(medianComposite, {bands: ['B4', 'B3', 'B2'], min: 0, max: 3000}, 'Median Composite');\n</code></pre>"},{"location":"imgcollection-class10/#5-metadata-of-image-collection","title":"5. Metadata of Image Collection","text":"<p>Understanding the metadata associated with satellite imagery is essential for proper interpretation and analysis. Metadata includes information about acquisition date, sensor characteristics, cloud cover, and more.</p>"},{"location":"imgcollection-class10/#example-display-metadata-of-landsat-image","title":"Example: Display Metadata of Landsat Image","text":"<pre><code>var image = ee.Image(filteredLandsat.first());\nprint('Metadata:', image.getInfo());\n</code></pre>"},{"location":"imgcollection-class10/#capture-date-of-a-single-image","title":"Capture Date of a Single Image","text":"<p>To get the capture date of a single image in Google Earth Engine (GEE), you can use the <code>.get()</code> function to retrieve metadata properties associated with the image. Here's how you can do it:</p> <pre><code>// Select a single image from the collection\nvar singleImage = ee.Image(landsatCollection.first());\n\n// Get the capture date metadata property\nvar captureDate = singleImage.get('system:time_start');\n\n// Print the capture date\nprint('Capture Date:', ee.Date(captureDate).format('YYYY-MM-dd'));\n</code></pre> <p>Explanation:</p> <ol> <li>We select a single image from the filtered collection using <code>first()</code>.</li> <li>We use <code>.get()</code> to retrieve the metadata property <code>'system:time_start'</code>, which represents the capture date/time of the image.</li> <li>We convert the capture date/time to a human-readable format using <code>ee.Date().format()</code> and print it out.</li> </ol> <p>This code will print out the capture date of the selected Landsat image in the format 'YYYY-MM-dd'. You can adjust the image collection, point of interest, and date range as per your requirements.</p>"},{"location":"imgcollection-class10/#creating-simple-rgb-composite-and-false-color-composite","title":"Creating Simple RGB Composite and False-Color Composite","text":"<p>Simple RGB composites combine the red, green, and blue bands to visualize natural colors, while false-color composites utilize other spectral bands to enhance certain features, such as vegetation or urban areas.</p>"},{"location":"imgcollection-class10/#example-creating-simple-rgb-composite","title":"Example: Creating Simple RGB Composite","text":"<pre><code>var simpleRGB = medianComposite.visualize({bands: ['B4', 'B3', 'B2'], min: 0, max: 3000});\nMap.addLayer(simpleRGB, {}, 'Simple RGB Composite');\n</code></pre>"},{"location":"imgcollection-class10/#example-creating-false-color-composite","title":"Example: Creating False-Color Composite","text":"<pre><code>var falseColor = medianComposite.visualize({bands: ['B5', 'B4', 'B3'], min: 0, max: 3000});\nMap.addLayer(falseColor, {}, 'False-Color Composite');\n</code></pre> In a false color composite:  <ul> <li>Plant-covered land: Deep red</li> <li>Denser plant growth: Darker red</li> <li>Cities and exposed ground: Gray or tan</li> <li>Water: Blue or black</li> </ul>"},{"location":"imgcollection-class10/#assignment-10","title":"Assignment 10","text":"<p>\u2013 Select an image collection of any Satellite, filter by boundary and date. Finally, select an image from the collection, and print the capture date of that image. Upload the code and code link, and screenshot in your github  repo. Submit your repo link.</p> <p>\u2013 Make a RGB composite from any image collection for your Upazila. Upload the code and code link, and screenshot in your github  repo. Submit your repo link. </p> <p>\u2013 Make a False color composite from any image collection for your upazila. Upload the code and code link, and screenshot in your github  repo. Submit your repo link. </p> <p>Submision link: Check your email</p> <p>Dead line: 27 March, 2024</p>"},{"location":"indexCalculationClass11/","title":"Class 11 - Indices calculation from imagery","text":""},{"location":"indexCalculationClass11/#class-11","title":"Class 11","text":""},{"location":"indexCalculationClass11/#calculating-spectral-indices-in-google-earth-engine-gee","title":"Calculating Spectral Indices in Google Earth Engine (GEE)","text":"<p>Spectral indices leverage the unique reflectance properties of Earth's features in various electromagnetic spectrum bands captured by satellite sensors. By combining these bands with specific mathematical formulas, these indices enhance specific features, aiding in tasks like land cover analysis, vegetation monitoring, and other remote sensing applications.</p>"},{"location":"indexCalculationClass11/#understanding-spectral-indices","title":"Understanding Spectral Indices:","text":"<p>Each Earth feature has a characteristic spectral signature \u2013 how it reflects radiation across different wavelengths. Spectral indices exploit these differences to isolate and map specific features of interest. They are calculated by performing mathematical operations (typically subtraction and division) on specific bands from a satellite image. The resulting values often range from -1 to 1, with higher (or lower) values indicating a greater abundance of the target feature.</p>"},{"location":"indexCalculationClass11/#common-indices-and-band-selection-for-sentinel-2","title":"Common Indices and Band Selection for Sentinel-2:","text":"<p>Here are some commonly used indices and the Sentinel-2 bands employed for their calculation:</p> <ul> <li>Normalized Difference Vegetation Index (NDVI): Measures vegetation greenness by contrasting near-infrared (NIR) and red bands. Higher NDVI values indicate denser vegetation.</li> <li>Formula: <code>(B8 - B4) / (B8 + B4)</code> (where B8 is the near-infrared band and B4 is the red band in Sentinel-2)</li> <li>Normalized Difference Water Index (NDWI): Differentiates water bodies from land by contrasting green and near-infrared bands. Higher NDWI values suggest water presence.</li> <li>Formula: <code>(B3 - B8) / (B3 + B8)</code> (where B3 is the green band)</li> <li>Normalized Burn Ratio (NBR): Identifies burned areas by exploiting the distinct reflectance patterns of burned and healthy vegetation in near-infrared and shortwave-infrared bands. Lower NBR values indicate burn scars.</li> <li>Formula: <code>(B8 - B11) / (B8 + B11)</code> (where B11 is the shortwave-infrared band)</li> </ul>"},{"location":"indexCalculationClass11/#additional-normalized-difference-indices","title":"Additional Normalized Difference Indices:","text":"<p>Here are a few more commonly used normalized difference indices and their purposes:</p> <ul> <li>Normalized Difference Soil Index (NDSI):</li> <li>Formula: <code>(Shortwave-infrared1 - Red) / (Shortwave-infrared1 + Red)</code></li> <li>Purpose: Differentiates bare soil from vegetation. Higher NDSI values indicate exposed soil.</li> <li>Soil-Adjusted Vegetation Index (SAVI):</li> <li>Formula: <code>((NIR - Red) * (1 + L)) / (NIR + Red + L)</code> (where L is a soil adjustment factor, typically between 0.01 and 0.5)</li> <li>Purpose: Accounts for soil background effects, making it more sensitive to vegetation changes than NDVI, particularly in areas with low vegetation cover.</li> <li>Normalized Difference Drought Index (NDDI):</li> <li>Formula: <code>(NDVI - NDVI_min) / (NDVI_max - NDVI_min)</code> (where NDVI_min and NDVI_max are the minimum and maximum NDVI values for a specific region or time period)</li> <li>Purpose: Monitors drought stress in vegetation. Decreasing NDDI values over time might suggest drought conditions.</li> </ul> <p>These are just a few examples, and numerous other normalized difference indices exist, each tailored to specific applications in remote sensing. Remember to consult relevant scientific literature or GEE documentation for the most suitable index for your analysis.</p>"},{"location":"indexCalculationClass11/#example-ndvi-calculation","title":"Example (NDVI Calculation):","text":"<pre><code>// Import Sentinel-2 collection, filtered for 2023\nvar sentinel2 = ee.ImageCollection(\"COPERNICUS/S2/SR\")\n  .filterBounds(roi) //replace your ROI variable by your desired area\n  .filterDate(\"2023-01-01\", \"2023-12-31\")\n   .first();\n\n// Select the desired bands\nvar nir = sentinel2.select(\"B8\");\nvar red = sentinel2.select(\"B4\");\n\n// Calculate NDVI\nvar ndvi = nir.subtract(red).divide(nir.add(red));\n\n// Add NDVI layer to the map with a green-to-yellow color palette\nmap.addLayer(ndvi, {min: 0, max: 1, palette: [\"white\", \"yellow\", \"green\"]});\n\n// Optionally, export the NDVI image\nExport.image(ndvi, \"NDVI_2023_Sentinel2\", {scale: 10});\n</code></pre>"},{"location":"indexCalculationClass11/#why-those-bands-are-chosen-for-specific-indices","title":"Why Those Bands Are Chosen for Specific Indices","text":"<p>The choice of bands for calculating spectral indices hinges on the unique reflectance properties of different Earth features across the electromagnetic spectrum. Here's a deeper dive into why specific bands are used for the common indices mentioned earlier:</p> <p>Normalized Difference Vegetation Index (NDVI):</p> <ul> <li>Near-infrared (NIR): Healthy vegetation has high reflectance in the NIR band due to its cellular structure and chlorophyll content.</li> <li>Red: Chlorophyll strongly absorbs red light for photosynthesis.</li> </ul> <p>By contrasting these bands, NDVI effectively highlights areas with denser vegetation, as healthy plants reflect more NIR and absorb more red light, resulting in a higher NDVI value.</p> <p>Normalized Difference Water Index (NDWI):</p> <ul> <li>Green: Water bodies exhibit high reflectance in the green band.</li> <li>Near-infrared: Water absorbs NIR radiation.</li> </ul> <p>The difference between these bands emphasizes water features. High NDWI values indicate areas with a larger water presence.</p> <p>Normalized Burn Ratio (NBR):</p> <ul> <li>Near-infrared: Healthy vegetation reflects strongly in NIR.</li> <li>Shortwave-infrared (SWIR): Burned areas have increased reflectance in SWIR compared to healthy vegetation.</li> </ul> <p>By exploiting this contrasting behavior, NBR helps identify burned areas. Lower NBR values suggest burn scars, as burned materials tend to reflect more SWIR and less NIR</p>"},{"location":"indexCalculationClass11/#assignment-11","title":"Assignment 11","text":"<ul> <li>Make a NDVI map of your upazila by using Landsat 9 imagery for 2022. Upload the code, code link, and screenshot in your github repo. Submit the repo link.- 3 </li> <li>Make a NDWI map of your upazila by using Sentinel-2 imagery for 2023. Upload the code, code link, and screenshot in your github repo. Submit the repo link. -3</li> <li>Make a NDSI map of your upazila by using Sentinel-2 imagery for 2021. Upload the code, code link, and screenshot in your github repo. Submit the repo link. -3</li> <li>Calculate the maximum and minimum NDVI value of your NDVI map. Upload the code, code link, and screenshot in your github repo. Submit the repo link. -1</li> </ul> <p>Submision link: Check your email</p> <p>Dead line: 7 April, 2024</p>"},{"location":"intro-to-programming-with-js-class1/","title":"Class 1 - var, data type, comparison operator","text":"<p>At the very first class, we discuss about the below topics:</p> <ul> <li> <p>Variable in JavaScript</p> </li> <li> <p>Data Types in JavaScript</p> </li> <li>Data Type Conversion in JavaScript</li> <li>Comparison Operators in JavaScript</li> </ul> <p>The ultimate goal of this course is to gain proficiency in the Google Earth Engine JavaScript API, from basic to advanced concepts. Recognizing the importance of understanding fundamental programming concepts as a prerequisite, the course begins with JavaScript to build a solid foundation in programming. This approach ensures that participants are well-equipped with the necessary skills before exploring the intricacies of the Google Earth Engine JavaScript API. Let's get started! </p>"},{"location":"intro-to-programming-with-js-class1/#variable","title":"Variable","text":"<p>In programming, a variable is like a storage container that holds a value. It allows you to store and manipulate data within your code.</p>"},{"location":"intro-to-programming-with-js-class1/#declaring-variable-in-js","title":"Declaring Variable in JS","text":"<p>In JavaScript, you can declare a variable using the <code>var</code>, <code>let</code>, or <code>const</code> keyword. For GEE (Google Earth Engine), it's recommended to use <code>var</code>for compatibility with older browsers.</p> <pre><code>var myVariable = 42; // Declaration and assignment\n</code></pre> <p>In the above example, <code>myVariable</code> is declared using the <code>var</code> keyword and assigned the value <code>42</code>. This variable can now be used to store and manipulate data in the program.</p>"},{"location":"intro-to-programming-with-js-class1/#how-ram-handles-variable-addresses","title":"How RAM Handles Variable Addresses","text":"<p>Behind the scenes, when a variable is declared, the computer's memory (RAM - Random Access Memory) plays a crucial role. RAM is a form of volatile memory that stores data and machine code currently being used and processed by the computer.</p> <p>When a variable is declared, a specific portion of the computer's memory is allocated to store its value. The variable name acts as a reference or label for that memory location. This memory location has a unique address that the program uses to retrieve or update the stored value.</p>"},{"location":"intro-to-programming-with-js-class1/#variable-naming-rules","title":"Variable Naming Rules","text":"<ol> <li> <p>Variable names are case-sensitive (e.g., <code>myVariable</code> is different from <code>myvariable</code>).</p> </li> <li> <p>Variable names can include letters (a-z), numbers (0-9), underscores (_), and dollar signs ($).</p> </li> <li> <p>They cannot start with a number (e.g.,<code>person2</code> is allowed, but <code>2person</code> is not allowed).</p> </li> </ol>"},{"location":"intro-to-programming-with-js-class1/#basic-data-types","title":"Basic Data Types","text":"<p>Text/String: - Used for representing textual data. - Declared using single (<code>'</code>) or double (<code>\"</code>) quotes.</p> <p>Number: - Used for representing numerical data, both integers and floating-point numbers.</p> <p>Boolean: - Represents a logical entity and can have only two values: <code>true</code> or <code>false</code>.</p> <p>Certainly! Let's simplify and make the explanation more concise:</p> <p>Certainly! Let's include <code>toString()</code> in the explanation:</p>"},{"location":"intro-to-programming-with-js-class1/#data-type-conversion-in-javascript","title":"Data Type Conversion in JavaScript:","text":"<ol> <li>Automatic Type Conversion (Coercion):    JavaScript automatically converts data types during operations.</li> </ol> <pre><code>var num = 5;        \nvar str = \"10\";//10 is stroed as text      \nvar result = num + str;  //convert the data type of 5 from number to string, and then add with \"10\"\nconsole.log(result);  // \"510\"\n</code></pre> <ol> <li>Manual Type Conversion:    Developers can use builtin or custom functions for manual conversions.</li> </ol> <pre><code>var strNum = \"15\";\nvar num = Number(strNum);  \nconsole.log(num);  // 15\n</code></pre> <ol> <li>String to Number:    Convert strings to numbers using <code>Number()</code>, <code>parseInt()</code>, or <code>parseFloat()</code>.</li> </ol> <pre><code>var strNum = \"20\";\nvar num1 = Number(strNum);       \nvar num2 = parseInt(strNum);     \nvar num3 = parseFloat(strNum);   \n</code></pre> <ol> <li>Number to String:    Change numbers to strings by concatenating with an empty string, using <code>String()</code>, or <code>toString()</code> function.</li> </ol> <pre><code>var num = 25;\nvar str1 = num + \"\";       \nvar str2 = String(num);\nvar str3 = num.toString();     \n</code></pre> <p>Using <code>toString()</code> is another way to convert a number to a string, providing flexibility and options for developers.</p>"},{"location":"intro-to-programming-with-js-class1/#comparison-operator-in-javascript","title":"Comparison operator in JavaScript","text":"<p>In JavaScript, comparison operators are used to compare values and return a Boolean result (true or false). Here's a brief overview of some common comparison operators:</p> <ol> <li>Equal (==): Checks if two values are equal, but it performs type coercion, meaning it may convert the values to the same data type before making the comparison.</li> </ol> <pre><code>5 == '5'; // true (coerced equality)\n</code></pre> <ol> <li>Strict Equal (===): Compares both value and data type, ensuring that both are identical.</li> </ol> <pre><code>5 === '5'; // false (strict equality)\n</code></pre> <ol> <li>Not Equal (!=) and Strict Not Equal (!==): Similar to equal operators but negated.</li> </ol> <pre><code>5 != '5';  // false (coerced inequality)\n5 !== '5'; // true (strict inequality)\n</code></pre> <ol> <li>Greater Than (&gt;): Checks if the left operand is greater than the right operand.</li> </ol> <pre><code>10 &gt; 5; // true\n</code></pre> <ol> <li>Less Than (&lt;): Checks if the left operand is less than the right operand.</li> </ol> <pre><code>3 &lt; 7; // true\n</code></pre> <ol> <li>Greater Than or Equal (&gt;=) and Less Than or Equal (&lt;=): Check if the left operand is greater than or equal to, or less than or equal to, the right operand.</li> </ol> <pre><code>8 &gt;= 8; // true\n4 &lt;= 2; // false\n</code></pre> <p>These comparison operators are often used in conditional statements and expressions to control the flow of a program. They play a crucial role in decision-making processes. </p> <p>In this course, we will focus only those parts of JS which are required to learn GEE JS API.  If you are interested to learn JS you can find at w3schools.com, Mozila foundation, Freecodecamp. </p>"},{"location":"js-objects-class6/","title":"Class 6 - Object","text":"<p>Understanding Objects in JavaScript</p>"},{"location":"js-objects-class6/#what-are-objects-in-javascript","title":"What are Objects in JavaScript?","text":"<p>In JavaScript, an object is a composite data type that allows you to store data and methods (functions) together as a single entity. Objects are instances of classes, but JavaScript, being a prototype-based language, does not have classes in the traditional sense. Instead, objects can serve as blueprints for creating new objects through inheritance.</p>"},{"location":"js-objects-class6/#creating-objects","title":"Creating Objects","text":"<p>There are several ways to create objects in JavaScript:</p> <ol> <li>Object Literals: The simplest way to create an object is by using object literals, enclosed in curly braces <code>{}</code>.</li> </ol> <pre><code>let person = {\n    name: \"John\",\n    age: 30,\n    greet: function() {\n        return \"Hello, my name is \" + this.name;\n    }\n};\n</code></pre> <ol> <li>Constructor Functions: You can create objects using constructor functions, which are functions used to initialize objects.</li> </ol> <pre><code>function Person(name, age) {\n    this.name = name;\n    this.age = age;\n    this.greet = function() {\n        return \"Hello, my name is \" + this.name;\n    };\n}\n\nlet person = new Person(\"John\", 30);\n</code></pre>"},{"location":"js-objects-class6/#accessing-object-properties","title":"Accessing Object Properties","text":"<p>You can access object properties using dot notation or bracket notation:</p> <pre><code>console.log(person.name); // \"John\"\nconsole.log(person['age']); // 30\n</code></pre>"},{"location":"js-objects-class6/#object-methods","title":"Object Methods","text":"<p>Objects can contain methods, which are functions associated with the object:</p> <pre><code>console.log(person.greet()); // \"Hello, my name is John\"\n</code></pre>"},{"location":"js-objects-class6/#modifying-objects","title":"Modifying Objects","text":"<p>Objects in JavaScript are mutable, meaning you can modify their properties and methods after creation:</p> <pre><code>person.age = 35;\nconsole.log(person.age); // 35\n</code></pre>"},{"location":"js-objects-class6/#object-destructuring","title":"Object Destructuring","text":"<p>Object destructuring is a convenient way to extract multiple properties from an object and assign them to variables:</p> <pre><code>let { name, age } = person;\nconsole.log(name); // \"John\"\nconsole.log(age); // 35\n</code></pre> <p>Understanding Objects and the <code>this</code> Keyword in JavaScript</p> <p>JavaScript, renowned for its flexibility and power, relies heavily on objects as a core component of its programming paradigm. Objects allow developers to encapsulate data and behaviors into cohesive units, facilitating the creation of complex applications. Additionally, the <code>this</code> keyword plays a crucial role in how objects interact with their surrounding context. In this comprehensive guide, we'll explore the relationship between objects and the <code>this</code> keyword in JavaScript, shedding light on their usage and nuances.</p>"},{"location":"js-objects-class6/#objects-in-javascript","title":"Objects in JavaScript","text":"<p>In JavaScript, an object is a composite data type that serves as a container for properties and methods. Objects can be created using various methods, including object literals, constructor functions, and the <code>Object.create()</code> method. Here's a brief example of an object created using an object literal:</p> <pre><code>let person = {\n    name: \"John\",\n    age: 30,\n    greet: function() {\n        return \"Hello, my name is \" + this.name;\n    }\n};\n</code></pre> <p>In this example, <code>person</code> is an object containing properties such as <code>name</code> and <code>age</code>, along with a method <code>greet</code>. The <code>this</code> keyword within the <code>greet</code> method refers to the object itself, allowing access to its properties and methods.</p>"},{"location":"js-objects-class6/#the-this-keyword","title":"The <code>this</code> Keyword","text":"<p>The <code>this</code> keyword in JavaScript refers to the context in which a function is executed. Its value is determined dynamically based on how a function is called, rather than where it is defined. When used within an object method, <code>this</code> typically refers to the object that owns the method.</p> <p>Consider the following example:</p> <pre><code>let person = {\n    name: \"John\",\n    age: 30,\n    greet: function() {\n        return \"Hello, my name is \" + this.name;\n    }\n};\n\nconsole.log(person.greet()); // Output: \"Hello, my name is John\"\n</code></pre> <p>Here, <code>this.name</code> within the <code>greet</code> method refers to the <code>name</code> property of the <code>person</code> object.</p>"},{"location":"js-objects-class6/#handling-this-in-different-contexts","title":"Handling <code>this</code> in Different Contexts","text":"<p>The behavior of the <code>this</code> keyword can vary depending on how a function is invoked. For example, when a function is called as a standalone function, <code>this</code> typically refers to the global object (<code>window</code> in browsers, <code>global</code> in Node.js). However, when a function is called as a method of an object, <code>this</code> refers to that object.</p> <pre><code>function greet() {\n    return \"Hello, my name is \" + this.name;\n}\n\nlet person = {\n    name: \"John\",\n    greet: greet\n};\n\nconsole.log(person.greet()); // Output: \"Hello, my name is John\"\n</code></pre> <p>In this example, <code>this</code> within the <code>greet</code> function refers to the <code>person</code> object because <code>greet</code> is invoked as a method of <code>person</code>.</p>"},{"location":"logical-operator-loop-class3/","title":"Class 3 - Logical operator, loop","text":"<p>Logical Operators</p> <p>Logical operators in programming are symbols or keywords that are used to perform logical operations on Boolean values. Boolean values represent true or false, and logical operators allow you to combine or manipulate these values to make decisions in your program. </p>"},{"location":"logical-operator-loop-class3/#logical-operators-in-javascript","title":"Logical Operators in JavaScript","text":"<p>JavaScript supports three main logical operators: AND (<code>&amp;&amp;</code>), OR (<code>||</code>), and NOT (<code>!</code>).</p> <ol> <li>AND (<code>&amp;&amp;</code>):    The AND operator returns <code>true</code> only if both operands are <code>true</code>. Otherwise, it evaluates to <code>false</code>.</li> </ol> <pre><code>var result = true &amp;&amp; false; // result is false\n</code></pre> <ol> <li>OR (<code>||</code>):    The OR operator returns <code>true</code> if at least one of the operands is <code>true</code>. It evaluates to <code>false</code> only when both operands are <code>false</code>.</li> </ol> <pre><code>var result = true || false; // result is true\n</code></pre> <ol> <li>NOT (<code>!</code>):    The NOT operator negates the boolean value of its operand. If the operand is <code>true</code>, it becomes <code>false</code>; if it's <code>false</code>, it becomes <code>true</code>.</li> </ol> <pre><code>var result = !true; // result is false\n</code></pre>"},{"location":"logical-operator-loop-class3/#truth-tables","title":"Truth Tables","text":"<p>A truth table is a tabular representation of all possible outcomes of a logical expression. Let's create truth tables for the AND, OR, and NOT operators.</p> <ol> <li>AND Truth Table (<code>&amp;&amp;</code>):</li> </ol> Operand 1 Operand 2 Result true true true true false false false true false false false false <ol> <li>OR Truth Table (<code>||</code>):</li> </ol> Operand 1 Operand 2 Result true true true true false true false true true false false false <ol> <li>NOT Truth Table (<code>!</code>):</li> </ol> Operand Result true false false true"},{"location":"logical-operator-loop-class3/#practical-use-cases","title":"Practical Use Cases","text":"<p>Logical operators are frequently employed in conditional statements and loops, enhancing the decision-making capabilities of programs. Here's a simple example:</p> <pre><code>var x = 5;\nvar y = 10;\n\nif (x &gt; 0 &amp;&amp; y &gt; 0) {\n  console.log(\"Both x and y are positive.\");\n} else {\n  console.log(\"At least one of x or y is not positive.\");\n}\n</code></pre>"},{"location":"logical-operator-loop-class3/#loop","title":"Loop","text":"<p>A loop is a programming construct that allows a set of instructions to be repeated multiple times. JavaScript provides several types of loops, but the most common ones are the \"for\" loop and the \"while\" loop.</p>"},{"location":"logical-operator-loop-class3/#the-for-loop-in-javascript","title":"The For Loop in JavaScript:","text":"<p>The <code>for</code> loop in JavaScript is a powerful tool that allows you to repeat a set of instructions for a specified number of times. It consists of three optional expressions enclosed in parentheses, followed by a code block. Let's break down the structure of the <code>for</code> loop:</p> <pre><code>for (expression1; expression2; expression3) {\n  // code block to be executed\n}\n</code></pre>"},{"location":"logical-operator-loop-class3/#expression-1","title":"Expression 1:","text":"<p>The first expression, <code>expression1</code>, is executed once before the code block. This part of the loop is typically used to initialize a variable. For example:</p> <pre><code>for (var i = 0; i &lt; 5; i++) {\n  // code block to be executed\n}\n</code></pre> <p>In this example, <code>let i = 0</code> initializes a variable <code>i</code> to 0 before the loop begins.</p>"},{"location":"logical-operator-loop-class3/#expression-2","title":"Expression 2:","text":"<p>The second expression, <code>expression2</code>, defines the condition for executing the code block. The loop will continue running as long as this condition is true. Using the previous example:</p> <pre><code>for (var i = 0; i &lt; 5; i++) {\n  // code block to be executed\n}\n</code></pre> <p>Here, <code>i &lt; 5</code> is the condition. The loop will keep running as long as <code>i</code> is less than 5.</p>"},{"location":"logical-operator-loop-class3/#expression-3","title":"Expression 3:","text":"<p>The third expression, <code>expression3</code>, is executed after each execution of the code block. It is commonly used for incrementing or decrementing a variable. Continuing with the example:</p> <pre><code>for (var i = 0; i &lt; 5; i++) {\n  // code block to be executed\n}\n</code></pre> <p>In this case, <code>i++</code> increments the value of <code>i</code> by 1 after each iteration.</p> <p>Another example that counts from 1 to 5:</p> <pre><code>for (var i = 1; i &lt;= 5; i++) {\n  console.log(i);\n}\n</code></pre> <p>Explanation: - <code>var i = 1</code>: This initializes a variable <code>i</code> to 1. - <code>i &lt;= 5</code>: This is the condition that determines whether the loop should continue. It says, \"Continue looping as long as <code>i</code> is less than or equal to 5.\" - <code>i++</code>: This increments the value of <code>i</code> by 1 after each iteration.</p> <p>The loop prints the values of <code>i</code> to the console from 1 to 5.</p>"},{"location":"mapThreasholdingclass12/","title":"Class 12 - Value thresholding and area calculation","text":""},{"location":"mapThreasholdingclass12/#class-12","title":"Class 12","text":""},{"location":"mapThreasholdingclass12/#normalized-difference-indices-thresholding-and-area-calculation-using-google-earth-engine","title":"Normalized difference indices Thresholding and Area Calculation using Google Earth Engine","text":"<p>Normalized Difference inidices, thresholding is a widely used technique in remote sensing and satellite imagery analysis for classifying different land coveer conditions. In this lecture we will demonstrate how to perform NDVI thresholding and calculate the area for each threshold class using the Google Earth Engine JavaScript API.</p>"},{"location":"mapThreasholdingclass12/#step-1-import-image-collection","title":"Step 1: Import Image Collection","text":"<p>First, import the image collection containing the satellite images with bands required for NDVI calculation. We'll use Landsat 8 data in this example.</p> <pre><code>var collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n                  .filterDate('2019-01-01', '2019-12-31')\n                  .filterBounds(geometry);\n</code></pre>"},{"location":"mapThreasholdingclass12/#step-2-calculate-ndvi","title":"Step 2: Calculate NDVI","text":"<p>Next, calculate the NDVI for each image in the collection using the formula: (NIR - Red) / (NIR + Red), where NIR (Near-Infrared) is band 5 and Red is band 4.</p> <pre><code>var addNDVI = function(image) {\n  var img = image.select(\"SR_B5\",\"SR_B4\")\n  var ndvi = img.normalizedDifference(['SR_B5', 'SR_B4']).rename('NDVI');\n  return image.addBands(ndvi);\n};\nvar collectionNDVI = collection.map(addNDVI).mean();\nMap.addLayer(collectionNDVI.clip(geometry))\n</code></pre>"},{"location":"mapThreasholdingclass12/#step-3-thresholding","title":"Step 3: Thresholding","text":"<p>Define threshold classes based on NDVI values to classify different vegetation types or conditions. For example, we'll define classes for bare land, low vegetation, and high vegetation. You can change the upper and lower limit of the value as far your requirement. </p> <pre><code>var bareLand = collectionNDVI.select('NDVI').lt(0.1);\nvar lowVegetation = collectionNDVI.select('NDVI').gte(0.1).and(collectionNDVI.select('NDVI').lt(0.5));\nvar highVegetation = collectionNDVI.select('NDVI').gte(0.5);\n</code></pre>"},{"location":"mapThreasholdingclass12/#step-4-area-calculation","title":"Step 4: Area Calculation","text":"<p>Calculate the area for each threshold class using area-weighted multiplication and the <code>reduceRegion</code> function. </p> <pre><code>var areaBareLand = bareLand.multiply(ee.Image.pixelArea()).reduceRegion({\n  reducer: ee.Reducer.sum(),\n  geometry: geometry,\n  scale: 30,\n  maxPixels: 1e9\n});\n\nvar areaLowVegetation = lowVegetation.multiply(ee.Image.pixelArea()).reduceRegion({\n  reducer: ee.Reducer.sum(),\n  geometry: geometry,\n  scale: 30,\n  maxPixels: 1e9\n});\n\nvar areaHighVegetation = highVegetation.multiply(ee.Image.pixelArea()).reduceRegion({\n  reducer: ee.Reducer.sum(),\n  geometry: geometry,\n  scale: 30,\n  maxPixels: 1e9\n});\n\nprint('Area of Bare Land (in square meters):', areaBareLand.get('NDVI'));\nprint('Area of Low Vegetation (in square meters):', areaLowVegetation.get('NDVI'));\nprint('Area of High Vegetation (in square meters):', areaHighVegetation.get('NDVI'));\n</code></pre> <p>If you use a featureCollection or Shape file as your ROI, replace the <code>geometry: geometry</code> line by  by <code>geometry:roi.geometry()</code> </p>"},{"location":"mapThreasholdingclass12/#full-code","title":"Full code","text":"<pre><code>var collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n                  .filterDate('2019-01-01', '2019-12-31')\n                  .filterBounds(geometry);\nvar addNDVI = function(image) {\n  var img = image.select(\"SR_B5\",\"SR_B4\")\n  var ndvi = img.normalizedDifference(['SR_B5', 'SR_B4']).rename('NDVI');\n  return image.addBands(ndvi);\n};\n\nvar collectionNDVI = collection.map(addNDVI).mean();\n\nMap.addLayer(collectionNDVI.clip(geometry))\n\nvar bareLand = collectionNDVI.select('NDVI').lt(0.1);\nvar lowVegetation = collectionNDVI.select('NDVI').gte(0.1).and(collectionNDVI.select('NDVI').lt(0.5));\nvar highVegetation = collectionNDVI.select('NDVI').gte(0.5);\n\nvar areaBareLand = bareLand.multiply(ee.Image.pixelArea()).reduceRegion({\n  reducer: ee.Reducer.sum(),\n  geometry: geometry,\n  scale: 30,\n  maxPixels: 1e9\n});\n\nvar areaLowVegetation = lowVegetation.multiply(ee.Image.pixelArea()).reduceRegion({\n  reducer: ee.Reducer.sum(),\n  geometry: geometry,\n  scale: 30,\n  maxPixels: 1e9\n});\n\nvar areaHighVegetation = highVegetation.multiply(ee.Image.pixelArea()).reduceRegion({\n  reducer: ee.Reducer.sum(),\n  geometry: geometry,\n  scale: 30,\n  maxPixels: 1e9\n});\n\nprint('Area of Bare Land (in square meters):', areaBareLand.get('NDVI'));\nprint('Area of Low Vegetation (in square meters):', areaLowVegetation.get('NDVI'));\nprint('Area of High Vegetation (in square meters):', areaHighVegetation.get('NDVI'));\n</code></pre>"},{"location":"mapThreasholdingclass12/#assignmemnt-12","title":"Assignmemnt 12","text":"<ul> <li> <p>Make a NDVI map of your upazila by using Landsat 9 imagery for 2022. Generate 4 different classes and calculate area for each class by thresholding. Upload the code, code link, and screenshot in your github repo. Submit the repo link.- 5 </p> </li> <li> <p>Make a Normalized Difference Moisture Index (NDMI)  map of your upazila by using Landsat 9 imagery for 2023. Upload the code, code link, and screenshot in your github repo. Submit the repo link. -3</p> </li> <li> <p>Generate two PNG image of your NDVI, and NDMI map by using <code>getThumbURL()</code> function. Upload the code, code link, and screenshot in your github repo. Submit the repo link. - 2 </p> </li> </ul> <p>Submision link: Check your email</p> <p>Dead line: 10 May, 2024 </p>"},{"location":"pre-prog-basic/","title":"Pre programming Basic","text":""},{"location":"pre-prog-basic/#geospatial-programming-learning-course","title":"Geospatial Programming Learning Course","text":"<p>Pre-reading to start learning programming. This article covers the topics for the pre-test.</p>"},{"location":"pre-prog-basic/#journey-to-geospatial-programming-learning","title":"Journey to Geospatial Programming Learning","text":"<p>Welcome, learners! This is the very first step of learning programming. To get your hands on geospatial programming, the first step is to go through the basic concepts of a programming language. The fundamental blocks of all programming languages are more or less similar. In this article, we will go through the very basic fundamentals required to start our journey to geospatial programming. So let's get started!</p>"},{"location":"pre-prog-basic/#data-type","title":"Data Type","text":"<p>There are two basic types of data: quantitative and qualitative. Quantitative data is anything we can count, measure, or quantify with numbers. Qualitative data represents information in terms of language or description, which cannot be measured or counted.</p>"},{"location":"pre-prog-basic/#basic-data-types-in-programming","title":"Basic Data Types in Programming","text":"<p>Apart from numbers and text, we use another basic type of data in programming languages called boolean. Boolean has only two values: true and false.</p>"},{"location":"pre-prog-basic/#number-type-data","title":"Number Type Data","text":"<p>In programming, we primarily use three basic types of numbers: integer or whole number, decimal, and float.</p> <ul> <li>Integer and Decimal</li> </ul> <p>All positive, negative whole numbers including 0 are integers. A decimal number expresses fractions or whole numbers using a decimal point.</p> <ul> <li>String</li> </ul> <p>In programming, a \"string\" is a way to handle text or qualitative data. It could be a single word, a sentence, or even a collection of paragraphs. Strings are just sequences of characters, and they are handy for dealing with any kind of text-related information in programming.</p> <ul> <li>Boolean</li> </ul> <p>Boolean refers to a data type that can have one of two values: true or false. Boolean values are often used in conditional statements and expressions to make decisions in computer programs.</p>"},{"location":"pre-prog-basic/#uses-of-boolean-in-programming","title":"Uses of Boolean in Programming","text":"<ul> <li>Decision Making: Boolean helps programs decide what to do based on conditions.</li> <li>Comparison: It allows us to compare things, like whether one number is bigger than another.</li> <li>Logical Operation: Boolean helps express logical relationships.</li> <li>Looping: In programming, Boolean is used to repeat tasks until a condition is no longer true.</li> </ul>"},{"location":"pre-prog-basic/#example","title":"Example","text":"<p>Let <code>x = 9</code>, <code>y = 10</code>. Now we will compare if <code>x</code> and <code>y</code> have the same value. Is <code>x == y</code>? false.</p>"},{"location":"pre-prog-basic/#variable","title":"Variable","text":"<p>A variable is like a storage box in which we can keep different types of information. It's associated with a symbolic name and may have a memory address. The name allows referencing the data, and values can change during execution.</p>"},{"location":"pre-prog-basic/#declaring-a-variable","title":"Declaring a Variable","text":"<p>In most programming languages, declaring a variable involves giving it a name and specifying the type of data it will hold.</p> <pre><code>// Declare a variable named 'age' and assign the value 25 to it\nvar age = 25\n</code></pre>"},{"location":"pre-prog-basic/#arithmetic-operators","title":"Arithmetic Operators","text":"<p>Arithmetic operators are symbols used in programming to perform mathematical calculations on numerical data. They include addition, subtraction, multiplication, division, and modulus.</p>"},{"location":"pre-prog-basic/#basic-arithmetic-examples","title":"Basic Arithmetic Examples","text":"<ul> <li>Addition: <code>var total = 5 + 3; // total will be 8.</code></li> <li>Subtraction: <code>var difference = 10 - 4; // difference will be 6.</code></li> <li>Multiplication: <code>var product = 2 * 6; // product will be 12.</code></li> <li>Division: <code>var quotient = 8 / 2; // quotient will be 4.</code></li> <li>Modulus: <code>var remainder = 10 % 3; // remainder will be 1.</code></li> </ul>"},{"location":"pre-prog-basic/#adding-comments-inside-code-for-clarity","title":"Adding Comments inside Code for Clarity","text":"<p>A comment in programming is a piece of text that is not executed as part of the program but is included for human readers to understand the code. Comments provide explanations, notes, or reminders within the code to make it more readable and maintainable.</p>"},{"location":"pre-prog-basic/#example_1","title":"Example","text":"<pre><code>// This is a single-line comment \n\n/*\nThis is a\nmulti-line comment\n*/\n</code></pre> <p>Congratulations on completing the first step of your geospatial programming journey! Keep exploring and learning. Now you are ready to delve into any programming language.</p> <p>Join our Facebook group for discussions and support. Enroll in the cohort-2 of Geospatial Programming Course Google Form.</p> <p>Contact: geocoder.contact@gmail.com</p> <p>\u00a9 Geocodinglab.com</p>"},{"location":"raster-vector-data-in-gee/","title":"Class 8 - GIS data type and vector data in GEE","text":""},{"location":"raster-vector-data-in-gee/#creating-a-gee-account","title":"Creating a GEE account","text":"<p>Google Earth Engine is free for non-commercial and research purposes. You can create a GEE account in two ways: by registering a project in Google Cloud or by filling out a form.</p> <p>1) Register a cloud project</p> <p>2) Fill this form and submit your applicaiton</p> <p>You can also Watch this video.</p>"},{"location":"raster-vector-data-in-gee/#raster-and-vector-data","title":"Raster and Vector data","text":"<p>Raster and vector data are two fundamental types of spatial data used in Geographic Information Systems (GIS) and computer graphics. </p>"},{"location":"raster-vector-data-in-gee/#normal-computer-graphics","title":"Normal Computer Graphics:","text":"<p>In computer graphics, two primary methods are used to represent images: vector graphics and raster graphics.</p> <p>Raster Graphics:</p> <ul> <li>Raster graphics, also known as bitmap graphics, are composed of a grid of pixels, where each pixel contains color information.</li> <li>These images are resolution-dependent, meaning they can lose quality when scaled up.</li> <li>Common file formats for raster graphics include JPEG, PNG, and GIF.</li> <li>Raster images are suitable for photographs and complex images with varying colors and shades.</li> </ul> <p>Vector Graphics:</p> <ul> <li>Vector graphics are composed of mathematical formulas that define shapes and lines.</li> <li>Instead of using pixels, vector graphics use points, lines, curves, and shapes (e.g., circles, rectangles).</li> <li>These images are resolution-independent, meaning they can be scaled up without losing quality.</li> <li>Common file formats for vector graphics include SVG (Scalable Vector Graphics), AI (Adobe Illustrator), and EPS (Encapsulated PostScript).</li> <li>Vector images are suitable for illustrations, logos, and diagrams.</li> </ul>"},{"location":"raster-vector-data-in-gee/#transition-to-gis-geographic-information-systems","title":"Transition to GIS (Geographic Information Systems):","text":"<p>When we transition to the realm of Geographic Information Systems (GIS), both vector and raster data play essential roles in representing spatial information.</p> <p>Raster Data in GIS:</p> <ul> <li>In GIS, raster data represents geographic phenomena as a grid of cells, where each cell has a value representing a certain attribute (e.g., elevation, temperature, land cover).</li> <li>Satellite imagery, aerial photographs, and digital elevation models (DEMs) are common examples of raster data.</li> <li>Raster data is suitable for continuous spatial phenomena where values change continuously across the landscape.</li> </ul> <p>Vector Data in GIS:</p> <ul> <li>Vector data represents geographic features using discrete geometric objects such as points, lines, and polygons.</li> <li>Points represent specific locations (e.g., cities, sampling sites), lines represent linear features (e.g., roads, rivers), and polygons represent areas (e.g., administrative boundaries, land parcels).</li> <li>Vector data is used to represent discrete features and can store attribute information associated with each feature.</li> </ul>"},{"location":"raster-vector-data-in-gee/#applications-in-gis","title":"Applications in GIS:","text":"<p>In GIS applications, both raster and vector data are utilized for various purposes:</p> <p>Raster data is used for tasks such as:</p> <ul> <li>Terrain analysis (e.g., slope, aspect, visibility analysis).</li> <li>Land cover classification and change detection.</li> <li>Remote sensing applications (e.g., satellite image analysis).</li> <li>Continuous surface modeling (e.g., interpolation, hydrological modeling).</li> </ul> Figrue: Raster data source: arcgis.com  <p>Vector data is used for tasks such as:</p> <ul> <li>Geospatial analysis (e.g., buffer analysis, overlay operations).</li> <li>Network analysis (e.g., routing, transportation planning).</li> <li>Asset management (e.g., tracking infrastructure, facilities management).</li> <li>Cartographic representation (e.g., map production, thematic mapping).</li> </ul> Figrue: Vector data"},{"location":"raster-vector-data-in-gee/#types-of-vector-data","title":"Types of Vector data","text":"<p>Different types of vector data commonly used in Geographic Information Systems (GIS) include:</p> <p>Points:</p> <ul> <li> <p>Points represent specific locations on the Earth's surface or within a geographical area. Examples include:</p> </li> <li> <p>City locations</p> </li> <li>Sampling sites</li> <li>GPS coordinates</li> </ul> <p>Lines:</p> <ul> <li> <p>Lines represent linear features and are composed of a sequence of connected points. Examples include:</p> <ul> <li>Roads and highways</li> <li>Rivers and streams</li> <li>Utility lines (e.g., pipelines, power lines)</li> </ul> </li> </ul> <p>Polygons:</p> <ul> <li> <p>Polygons represent enclosed areas and are defined by a series of connected lines forming a closed loop. Examples include:</p> </li> <li> <p>Administrative boundaries (e.g., country borders, state boundaries)</p> </li> <li>Land parcels</li> <li>Ecological zones</li> </ul> <p>Multi-Points:    - Multi-points represent collections of individual points grouped together. Examples include:</p> <pre><code> - Sets of landmarks or features with multiple points of interest (e.g., tourist attractions within a park)\n</code></pre> <p>Multi-Lines:    - Multi-lines represent collections of individual lines grouped together. Examples include:      - Transportation networks with multiple road segments forming a route      - River networks with multiple streams or tributaries</p> <p>Multi-Polygons:    - Multi-polygons represent collections of individual polygons grouped together. Examples include:</p> <pre><code> - Complex land use zones with multiple discrete areas (e.g., residential, commercial, industrial)\n - Administrative regions composed of multiple subunits (e.g., districts within a city, counties within a state)\n</code></pre> <p>These are some common types of vector data used in GIS applications. Each type serves a specific purpose and can be used individually or in combination to represent spatial features and attributes accurately.</p>"},{"location":"raster-vector-data-in-gee/#vector-data-in-gee","title":"Vector data in GEE","text":"<p>In the context of the Google Earth Engine (GEE) JavaScript API, geometry, feature, and feature collection are fundamental concepts used to represent and work with spatial data. Here's a discussion on each:</p> <ol> <li> <p>Geometry:</p> </li> <li> <p>In GEE, a geometry represents a geometric shape or spatial extent defined by points, lines, or polygons in geographic coordinates (latitude and longitude).</p> </li> <li>Geometries can be simple, such as a single point or a line, or complex, such as a polygon representing the boundary of a region.</li> <li>Geometries are often used to define regions of interest, boundaries, or areas for spatial analysis and processing.</li> <li>Common geometry types include Point, LineString, LinearRing, Polygon, MultiPoint, MultiLineString, and MultiPolygon.</li> </ol> <p>1.1 Point:</p> <pre><code>// Create a Point geometry\nvar point = ee.Geometry.Point([-122.084, 37.422]);\n\n// Center the map on the point\nMap.centerObject(point, 10);\n\n// Add point as a layer to the map\nMap.addLayer(point, {color: 'red'}, 'Point');\n</code></pre> <p>1.2 LineString:</p> <pre><code>// Create a LineString geometry\nvar lineString = ee.Geometry.LineString(\n  [[-122.092, 37.424], [-122.086, 37.418], [-122.084, 37.422]]\n);\n\n// Center the map on the lineString\nMap.centerObject(lineString, 10);\n\n// Add lineString as a layer to the map\nMap.addLayer(lineString, {color: 'blue'}, 'LineString');\n</code></pre> <p>1.3 Polygon:</p> <pre><code>// Create a Polygon geometry\nvar polygon = ee.Geometry.Polygon(\n  [[[-122.088, 37.426], [-122.082, 37.426], [-122.082, 37.422], [-122.088, 37.422]]]\n);\n\n// Center the map on the polygon\nMap.centerObject(polygon, 10);\n\n// Add polygon as a layer to the map\nMap.addLayer(polygon, {color: 'green'}, 'Polygon');\n</code></pre> <ol> <li> <p>Feature:</p> </li> <li> <p>A feature in GEE represents a spatially explicit object associated with a geometry and a set of properties or attributes.</p> </li> <li>Features can represent real-world entities such as cities, rivers, buildings, or administrative boundaries.</li> <li>Each feature contains a geometry (described above) and a collection of key-value pairs representing properties. These properties could include information like name, population, elevation, or any other relevant attribute.</li> <li>Features are often used to organize and analyze spatial data, enabling users to attach additional information to geometries and perform queries or analysis based on these attributes.</li> </ol> <pre><code>// Define a feature with a point geometry and properties\nvar cityFeature = ee.Feature(point, {name: 'San Francisco', population: 884363});\n\n\n// Center the map on the feature\nMap.centerObject(cityFeature, 10);\n\n// Add feature as a layer to the map\nMap.addLayer(cityFeature, {}, 'City Feature');\n</code></pre> <ol> <li>Feature Collection:</li> <li>A feature collection is a group or collection of features, each with its own geometry and properties.</li> <li>Feature collections allow users to organize and manage multiple spatial features within a single data structure.</li> <li>Feature collections can represent various types of spatial data, including point clouds, vector datasets, or even collections of satellite imagery.</li> <li>Feature collections are often used as inputs for spatial analysis algorithms, visualization layers on maps, or storage containers for spatial datasets.</li> <li>Feature collections can be created by importing data from external sources, generating geometries programmatically, or aggregating individual features into a collection.</li> </ol> <pre><code>// Create a feature collection and add features to it\nvar featureCollection = ee.FeatureCollection([\n  ee.Feature(point, {name: 'San Francisco', population: 884363}),\n  ee.Feature(polygon, {name: 'San Francisco Bay Area', areaSqKm: 10685})\n]);\n\n// Center the map on the feature collection\nMap.centerObject(featureCollection, 10);\n\n// Add feature collection as a layer to the map\nMap.addLayer(featureCollection, {}, 'Feature Collection');\n</code></pre>"},{"location":"raster-vector-data-in-gee/#assignment-8","title":"Assignment 8","text":"<ul> <li>Draw a  rectangle, a point, and a polygon in Google Earth Engine, take a screenshot, and upload the screenshot and the code in your github repo. Submit your github repo link below.</li> <li>Draw a feature collection of 5 polygons covering water bodies in your area. Take a screenshot. Then, upload the code and screenshot in your github repo. Submit your github repo link </li> <li>Open this code in GEE  and take a screenshot of the boundary of Bangladesh. Upload in your github repo and submit the repo link </li> <li>Open this code in GEE and change the division name to yours. Take a screenshot of your division map and upload it to github. Submit the repo link. </li> </ul> <p>Dead line: 10 March, 2024</p>"},{"location":"shapeFiles/","title":"shapeFiles","text":"<ol> <li>[Shape file of Bangladesh Admin 4 (union level boundaries)] (shape_files/bd_admin_4_union.geojson)</li> </ol>"},{"location":"supmlclass15/","title":"Class 15 - Supervised and unSupervised Machine learning","text":""},{"location":"supmlclass15/#class-15","title":"Class 15","text":""},{"location":"supmlclass15/#supervised-and-unsupervised-machine-learning","title":"Supervised and Unsupervised Machine Learning","text":""},{"location":"supmlclass15/#1-definition-and-purpose","title":"1. Definition and Purpose","text":"<ul> <li>Supervised Machine Learning:</li> <li>Definition: A type of machine learning where the model is trained on labeled data, meaning each training example is paired with an output label.</li> <li> <p>Purpose: To predict the output for new data based on the learned relationship from the training data. It is primarily used for classification and regression tasks.</p> </li> <li> <p>Unsupervised Machine Learning:</p> </li> <li>Definition: A type of machine learning where the model is trained on unlabeled data and tries to find hidden patterns or intrinsic structures in the input data.</li> <li>Purpose: To discover the underlying structure of the data, group similar data points, and identify anomalies without prior knowledge of output labels. It is mainly used for clustering and dimensionality reduction.</li> </ul>"},{"location":"supmlclass15/#2-data-requirements","title":"2. Data Requirements","text":"<ul> <li>Supervised Machine Learning:</li> <li>Data Requirement: Requires a labeled dataset, where each data point is annotated with the correct output.</li> <li> <p>Example: In land cover classification, each sample point needs a label indicating the type of land cover (e.g., forest, water, urban).</p> </li> <li> <p>Unsupervised Machine Learning:</p> </li> <li>Data Requirement: Works with unlabeled data, where no output labels are provided.</li> <li>Example: In clustering land cover types, the algorithm groups pixels with similar spectral properties without needing predefined labels.</li> </ul>"},{"location":"supmlclass15/#3-training-process","title":"3. Training Process","text":"<ul> <li>Supervised Machine Learning:</li> <li>Training Process: The algorithm learns from the labeled data by mapping input features to the correct output label. It uses this mapping to predict labels for new data.</li> <li> <p>Example: Training a classifier to distinguish between different types of land cover based on spectral signatures.</p> </li> <li> <p>Unsupervised Machine Learning:</p> </li> <li>Training Process: The algorithm explores the input data to identify natural groupings or patterns without any external guidance.</li> <li>Example: Performing K-means clustering to segment an image into regions of similar spectral properties.</li> </ul>"},{"location":"supmlclass15/#4-output","title":"4. Output","text":"<ul> <li>Supervised Machine Learning:</li> <li>Output: Produces a model that can predict the label or value for new, unseen data based on learned patterns from the training data.</li> <li> <p>Example: A classified map where each pixel is assigned a specific land cover type.</p> </li> <li> <p>Unsupervised Machine Learning:</p> </li> <li>Output: Generates a set of clusters or groups from the data, which can reveal patterns, relationships, or structures within the data.</li> <li>Example: A segmented map showing distinct regions based on spectral similarity, without specific labels.</li> </ul>"},{"location":"supmlclass15/#5-applications","title":"5. Applications","text":"<ul> <li>Supervised Machine Learning:</li> <li> <p>Applications: Used in scenarios where labeled training data is available, such as:</p> <ul> <li>Land cover classification</li> <li>Crop type identification</li> <li>Predictive modeling in various fields (e.g., finance, healthcare)</li> </ul> </li> <li> <p>Unsupervised Machine Learning:</p> </li> <li>Applications: Suitable for exploratory data analysis and scenarios where labels are not available, such as:<ul> <li>Clustering similar regions in satellite imagery</li> <li>Anomaly detection</li> <li>Market basket analysis</li> </ul> </li> </ul>"},{"location":"supmlclass15/#introduction-to-machine-learning-algorithms-in-google-earth-engine-gee-javascript-api","title":"Introduction to Machine Learning Algorithms in Google Earth Engine (GEE) JavaScript API","text":"<p>Google Earth Engine (GEE) provides a powerful platform for geospatial analysis, including the implementation of machine learning algorithms. This tutorial will introduce you to supervised and unsupervised machine learning concepts, with examples using the GEE JavaScript API.</p>"},{"location":"supmlclass15/#supervised-machine-learning","title":"Supervised Machine Learning","text":"<p>Supervised learning involves training a model on labeled data. The model learns to predict the output based on input features.</p> <p>Example: Land Cover Classification</p> <ol> <li>Prepare Training Data:    Collect samples representing different land cover types.</li> </ol> <pre><code>var trainingPolygons = ee.FeatureCollection([\n  ee.Feature(geometry1, {'class': 0}), // e.g., water\n  ee.Feature(geometry2, {'class': 1}), // e.g., forest\n  ee.Feature(geometry3, {'class': 2})  // e.g., urban\n]);\n</code></pre> <ol> <li>Load and Prepare Imagery:    Use satellite imagery, such as Sentinel-2.</li> </ol> <pre><code>var image = ee.ImageCollection('COPERNICUS/S2')\n                .filterDate('2022-01-01', '2022-12-31')\n                .median();\nvar bands = ['B2', 'B3', 'B4', 'B8']; // Blue, Green, Red, NIR\nvar input = image.select(bands);\n</code></pre> <ol> <li>Extract Training Data:    Sample the image using the training polygons.</li> </ol> <pre><code>var training = input.sampleRegions({\n  collection: trainingPolygons,\n  properties: ['class'],\n  scale: 30\n});\n</code></pre> <ol> <li>Train the Classifier:    Use a classifier like CART (Classification and Regression Trees).</li> </ol> <pre><code>var classifier = ee.Classifier.smileCart().train({\n  features: training,\n  classProperty: 'class',\n  inputProperties: bands\n});\n</code></pre> <ol> <li>Classify the Image:</li> </ol> <pre><code>var classified = input.classify(classifier);\nMap.addLayer(classified, {min: 0, max: 2, palette: ['blue', 'green', 'red']}, 'Land Cover');\n</code></pre>"},{"location":"supmlclass15/#unsupervised-machine-learning","title":"Unsupervised Machine Learning","text":"<p>Unsupervised learning finds patterns or groupings in data without labeled examples.</p> <p>Example: K-means Clustering for Land Cover Segmentation</p> <ol> <li>Load and Prepare Imagery:    Use the same steps as in the supervised example.</li> </ol> <pre><code>var image = ee.ImageCollection('COPERNICUS/S2')\n                .filterDate('2022-01-01', '2022-12-31')\n                .median();\nvar bands = ['B2', 'B3', 'B4', 'B8']; // Blue, Green, Red, NIR\nvar input = image.select(bands);\n</code></pre> <ol> <li>Sample the Image:    Randomly sample the image to create a dataset for clustering.</li> </ol> <pre><code>var sample = input.sample({\n  region: regionOfInterest,\n  scale: 30,\n  numPixels: 5000\n});\n</code></pre> <ol> <li>Perform K-means Clustering:    Cluster the samples into groups.</li> </ol> <pre><code>var clusterer = ee.Clusterer.wekaKMeans(3).train(sample);\nvar result = input.cluster(clusterer);\n</code></pre> <ol> <li>Visualize the Clusters:</li> </ol> <pre><code>Map.addLayer(result.randomVisualizer(), {}, 'Clusters');\n</code></pre>"},{"location":"supmlclass15/#assignmemnt-15","title":"Assignmemnt 15","text":"<ol> <li>Do a supervised classification by using Sentinel-2 for your upazila, export the classified image, prepare fine-tuned map </li> <li>Do a unsupervised classification by using Landsat-9 for your upazila, export the classified image, prepare fine-tuned map </li> </ol> <p>Submision link: Check your email</p> <p>Dead line:  3 June, 2024 </p>"}]}